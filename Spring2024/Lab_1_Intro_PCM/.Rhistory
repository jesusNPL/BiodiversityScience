c(logLik(pglsModel)[[1]], logLik(mod.r)[[1]])
max(c(logLik(pglsModel)[[1]], logLik(mod.r)[[1]]))
min(c(logLik(pglsModel)[[1]], logLik(mod.r)[[1]]))
furnaVariables
R2_lik(pglsModel)
round(R2_lik(pglsModel))
round(R2_lik(pglsModel), 2)
## Loglik of the PGLS model
logLik(pglsModel)
## Estimate null model
y <- as.numeric(fitted(pglsModel) + resid(pglsModel))
nullModel <- lm(y ~ 1)
## loglik null model
logLik(nullModel)
R2_lik(pglsModel, mod.r)
R2_lik(pglsModel, nullModel)
R2_lik(mod = pglsModel, mod.r = nullModel)
View(R2_lik.gls)
?R2_lik
logLik(pglsModel) > logLik(nullModel)
## Loglik of the PGLS model
logLik(pglsModel)
## Estimate null model or intercept-only model
y <- as.numeric(fitted(pglsModel) + resid(pglsModel))
nullModel <- lm(y ~ 1)
## loglik null model
logLik(nullModel)
## Is higher
logLik(pglsModel) > logLik(nullModel)
summary(pglsModel)
summary(lm_hwi_rangesize)
#| eval: true
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray", size = 3) +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)")
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm")
#| eval: true
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "Hand-Wing Index", y = "log(Range Size)") +
#geom_smooth(method = "lm") +
geom_abline(intercept = coef(pglsModel)[1], slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5)
# will plot the pgls regression line on your biplot.
#| eval: false
brownianModel <- fitContinuous(phy = furnariidaeTree, # phylogeny
dat = hwi, # trait
model = "BM") # evolutionary model
#| eval: false
OUModel <- fitContinuous(phy = furnariidaeTree,
dat = hwi,
model = "OU")
#| eval: false
EBModel <- fitContinuous(phy = furnariidaeTree,
dat = hwi,
model = "EB")
#| eval: true
# Vector of models
mods <- c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc)
# rename the models
names(mods) <- c("BM", "OU", "EB")
# Run AIC weights
aicw(mods)
#| eval: true
# Vector of models
mods <- c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc)
# rename the models
names(mods) <- c("BM", "OU", "EB")
# Run AIC weights
table(aicw(mods))
#| eval: true
# Vector of models
mods <- c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc)
# rename the models
names(mods) <- c("BM", "OU", "EB")
# Run AIC weights
aicw(mods)
class(aicw(mods))
#| eval: false
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm", se = FALSE, linewidth = 1.5) + # OLS slope
geom_abline(intercept = coef(pglsModel)[1], # PGLS slope
slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5)
#| eval: false
rshwi.sum <- summary(lm_hwi_rangesize)
#for the uncorrected linear model
rshwi.sum$coef[2, 1] + c(-1.96, 1.96)*rshwi.sum$coef[2, 2]
#for Brownian Motion, the 95% CI
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])
#| eval: false
# Run Blomber's K
K_hwi <- phylosig(tree = furnariidaeTree, # Phylogeny
x = hwi, # trait
method = "K", # method
test = TRUE)
# Print results
print(K_hwi)
# Plot results
plot(K_hwi)
#| eval: false
# Run Pagel's Lambda
LB_hwi <- phylosig(tree = furnaTree,
x = hwi,
method = "lambda",
test = TRUE)
# Print the results
print(LB_hwi)
# Plot thre results
plot(LB_hwi)
#| eval: true
# Vector of models
mods <- c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc)
# rename the models
names(mods) <- c("BM", "OU", "EB")
# Run AIC weights
kable(aicw(mods))
# Run AIC weights
library(knitr)
kable(aicw(mods))
#| eval: true
library(knitr)
# Vector of models
mods <- c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc)
# rename the models
names(mods) <- c("BM", "OU", "EB")
# Run AIC weights
kable(aicw(mods))
#| eval: true
# Vector of models
mods <- c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc)
# rename the models
names(mods) <- c("BM", "OU", "EB")
# Run AIC weights
aicw(mods)
aic_HWI <- aicw(mods)
names(aic_HWI)
names(aic_HWI)[1] <- "AIC"
names(aic_HWI)
library(knitr)
aic_HWI <- aicw(mods)
names(aic_HWI)[1] <- "AIC"
kable(aic_HWI)
brownianModel
OUModel
EBModel
OUModel$opt$lnL
library(knitr)
aic_HWI <- aicw(mods)
names(aic_HWI)[1] <- "AIC"
aic_HWI$logLik <- c(brownianModel$opt$lnL, OUModel$opt$lnL, EBModel$opt$lnL)
kable(aic_HWI)
library(knitr)
aic_HWI <- aicw(mods)
names(aic_HWI)[1] <- "AIC"
aic_HWI$lnL <- c(brownianModel$opt$lnL, OUModel$opt$lnL, EBModel$opt$lnL)
kable(aic_HWI)
hwi
log(hwi)
par(mfrow = c(1, 2))
hist(hwi)
hist(log(hwi))
#| eval: true
brownianModel <- fitContinuous(phy = furnariidaeTree, # phylogeny
dat = log(hwi), # trait
model = "BM") # evolutionary model
brownianModel
#| eval: true
OUModel <- fitContinuous(phy = furnariidaeTree,
dat = log(hwi),
model = "OU")
OUModel
#| eval: true
EBModel <- fitContinuous(phy = furnariidaeTree,
dat = log(hwi),
model = "EB")
EBModel
#| eval: true
# Vector of models
mods <- c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc)
# rename the models
names(mods) <- c("BM", "OU", "EB")
# Run AIC weights
aicw(mods)
library(knitr)
aic_HWI <- aicw(mods)
names(aic_HWI)[1] <- "AIC"
aic_HWI$lnL <- c(brownianModel$opt$lnL, OUModel$opt$lnL, EBModel$opt$lnL)
kable(aic_HWI)
rangeSize
log(rangeSize)
hist(log(rangeSize))
hist(rangeSize)
BM_RS <- fitContinuous(phy = furnariidaeTree, # phylogeny
dat = log(rangeSize), # trait
model = "BM") # evolutionary model
OU_RS <- fitContinuous(phy = furnariidaeTree,
dat = log(rangeSize),
model = "OU")
EB_RS <- fitContinuous(phy = furnariidaeTree,
dat = log(rangeSize),
model = "EB")
# Vector of models
mods_RS <- c(BM_RS$opt$aicc, OU_RS$opt$aicc, EB_RS$opt$aicc)
# rename the models
names(mods_RS) <- c("BM", "OU", "EB")
# Run AIC weights
aic_RS <- aicw(mods_RS)
names(aic_RS)[1] <- "AIC"
aic_RS$lnL <- c(BM_RS$opt$lnL, OU_RS$opt$lnL, EB_RS$opt$lnL)
kable(aic_RS)
BM_RS <- fitContinuous(phy = furnariidaeTree, # phylogeny
dat = log(rangeSize), # trait
model = "BM") # evolutionary model
OU_RS <- fitContinuous(phy = furnariidaeTree,
dat = log(rangeSize),
model = "OU")
EB_RS <- fitContinuous(phy = furnariidaeTree,
dat = log(rangeSize),
model = "EB")
# Vector of models
mods_RS <- c(BM_RS$opt$aicc, OU_RS$opt$aicc, EB_RS$opt$aicc)
# rename the models
names(mods_RS) <- c("BM", "OU", "EB")
# Run AIC weights
aic_RS <- aicw(mods_RS)
names(aic_RS)[1] <- "AIC"
aic_RS$lnL <- c(BM_RS$opt$lnL, OU_RS$opt$lnL, EB_RS$opt$lnL)
kable(aic_RS)
#| eval: true
rshwi.sum <- summary(lm_hwi_rangesize)
#for the uncorrected linear model
rshwi.sum$coef[2, 1] + c(-1.96, 1.96)*rshwi.sum$coef[2, 2]
#for Brownian Motion, the 95% CI
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])
#| eval: true
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm", se = FALSE, linewidth = 1.5) + # OLS slope
geom_abline(intercept = coef(pglsModel)[1], # PGLS slope
slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5)
#| eval: true
rshwi.sum <- summary(lm_hwi_rangesize)
#for the uncorrected linear model
rshwi.sum$coef[2, 1] + c(-1.96, 1.96)*rshwi.sum$coef[2, 2]
#for Brownian Motion, the 95% CI
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])
#| eval: true
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm", se = FALSE, linewidth = 1.5) + # OLS slope
geom_abline(intercept = coef(pglsModel)[1], # PGLS slope
slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5)
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm", se = TRUE, linewidth = 1.5) + # OLS slope
geom_abline(intercept = coef(pglsModel)[1], # PGLS slope
slope = coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2]),
color = "red", linewidth = 1.5)
#| eval: true
rshwi.sum <- summary(lm_hwi_rangesize)
#for the uncorrected linear model
rshwi.sum$coef[2, 1] + c(-1.96, 1.96)*rshwi.sum$coef[2, 2]
#for Brownian Motion, the 95% CI
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])
sqrt(pglsModel$varBeta[2, 2])
pglsModel$varBeta
coef(pglsModel)
coef(pglsModel)[2]
summary(pglsModel)
rshwi.sum$coef
rshwi.sum$coef[2, 1]
rshwi.sum$coef[2, 2]
pglsModel$varBeta[2, 2]
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])[1]
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])[[1]]
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm", se = FALSE, linewidth = 1.5) + # OLS slope
geom_abline(intercept = coef(pglsModel)[1], # PGLS slope
slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5) +
geom_ribbon(aes(ymin = 1.409242, ymax = 4.960522, linetype = 2, alpha = 0.1))
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm", se = FALSE, linewidth = 1.5) + # OLS slope
geom_abline(intercept = coef(pglsModel)[1], # PGLS slope
slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5) +
geom_abline(aes(ymin = 1.409242, ymax = 4.960522, linetype = 2, alpha = 0.1))
#| eval: true
# Run Blomber's K
K_hwi <- phylosig(tree = furnariidaeTree, # Phylogeny
x = hwi, # trait
method = "K", # method
test = TRUE)
# Print results
print(K_hwi)
# Plot results
plot(K_hwi)
#| eval: true
# Run Pagel's Lambda
LB_hwi <- phylosig(tree = furnaTree,
x = hwi,
method = "lambda",
test = TRUE)
# Print the results
print(LB_hwi)
# Plot thre results
plot(LB_hwi)
round(0.949391 , 2)
round(1.23553 , 2)
# Run Blomber's K
K_rs <- phylosig(tree = furnariidaeTree, # Phylogeny
x = rangeSize, # trait
method = "K", # method
test = TRUE)
# Print results
print(K_rs)
# Plot results
plot(K_rs)
# Run Pagel's Lambda
LB_rs <- phylosig(tree = furnaTree,
x = rangeSize,
method = "lambda",
test = TRUE)
# Print the results
print(LB_rs)
# Plot thre results
plot(LB_rs)
round(0.495918 ,1)
round(0.495918 ,2)
round(0.723693 ,2)
library(tidyverse)
library(ape)
library(geiger)
library(nlme)
library(phytools)
library(rr2)
## Trait data
furnaData <- read_csv("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2024/Lab_1_Intro_PCM/Data/furnariides_traits.csv") %>%
column_to_rownames("Sciname") %>%   # we are using the column "Sciname" as rownames
drop_na(Range.Size)
## Phylogenetic data
furnaTree <- read.nexus("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2024/Lab_1_Intro_PCM/Data/furnariides_tree.nex")
glimpse(furnaData)
tmp <- name.check(phy = furnaTree, data = furnaData)
# print the results
tmp
furnaTree <- drop.tip(phy = furnaTree, tip = tmp$tree_not_data)
name.check(phy = furnaTree, data = furnaData)
#| eval: false
furnaData %>%
head() # this will show you the first few rows of your data matrix and its header
furnaData %>%
dimnames() # this will show you the row and column headers for your matrix
furnaData %>%
View() # this will let you visualize the entire matrix
furnariidaeData <- furnaData %>%
filter(Family3 == "Furnariidae")
furnariidaeTree <- drop.tip(phy = furnaTree,
tip = setdiff(furnaTree$tip.label, rownames(furnariidaeData)))
hwi <- furnariidaeData[, "Hand-Wing.Index"]
names(hwi) <- rownames(furnariidaeData)
# data vectors have to be labelled with tip names for the associated tree.
# This is how to do that.
hist(hwi)
#| eval: false
brownianModel <- fitContinuous(phy = furnariidaeTree,
dat = log(hwi))
brownianModel # this will show you the fit statistics and parameter values
fitContinuous(phy = furnariidaeTree,
dat = hwi)
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm")
#| eval: false
pglsModel <- gls(log(rangeSize) ~ log(hwi),
correlation = corBrownian(phy = furnariidaeTree,
form=~names(rangeSize)),
method = "ML")
#| eval: false
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray", size = 3) +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)")
#| eval: false
brownianModel <- fitContinuous(phy = furnariidaeTree,
dat = log(hwi))
brownianModel # this will show you the fit statistics and parameter values
#| eval: false
rangeSize <- furnariidaeData[, "Range.Size"]
names(rangeSize) <- rownames(furnariidaeData)
#| eval: false
rangeSize <- furnariidaeData[, "Range.Size"]
names(rangeSize) <- rownames(furnariidaeData)
#| eval: false
hist(log(rangeSize))
#| eval: false
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray", size = 3) +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)")
#| eval: false
lm_hwi_rangesize <- lm(log(rangeSize) ~ log(hwi))
summary(lm_hwi_rangesize)
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "log(Hand-Wing Index)", y = "log(Range Size)") +
geom_smooth(method = "lm")
#| eval: false
pglsModel <- gls(log(rangeSize) ~ log(hwi),
correlation = corBrownian(phy = furnariidaeTree,
form=~names(rangeSize)),
method = "ML")
pglsModel
#| eval: false
summary(pglsModel)
coef(pglsModel)
# R2lik is based on the likelihood of fitted models and therefore reflects the amount of information that the models contain.
#And R2lik is most appropriate to assess the importance of different components within the same model applied to the same data, because it is most closely associated with statistical significance tests.
R2_lik(mod = pglsModel)
#| eval: false
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = log(`Hand-Wing.Index`), y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "Hand-Wing Index", y = "log(Range Size)") +
#geom_smooth(method = "lm") +
geom_abline(intercept = coef(pglsModel)[1], slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5)
# will plot the pgls regression line on your biplot.
#| eval: false
brownianModel <- fitContinuous(phy = furnariidaeTree, # phylogeny
dat = hwi, # trait
model = "BM") # evolutionary model
BM_RS <- fitContinuous(phy = furnariidaeTree, # phylogeny
dat = log(rangeSize), # trait
model = "BM") # evolutionary model
OU_RS <- fitContinuous(phy = furnariidaeTree,
dat = log(rangeSize),
model = "OU")
EB_RS <- fitContinuous(phy = furnariidaeTree,
dat = log(rangeSize),
model = "EB")
# Vector of models
mods_RS <- c(BM_RS$opt$aicc, OU_RS$opt$aicc, EB_RS$opt$aicc)
# rename the models
names(mods_RS) <- c("BM", "OU", "EB")
# Run AIC weights
aic_RS <- aicw(mods_RS)
names(aic_RS)[1] <- "AIC"
aic_RS$lnL <- c(BM_RS$opt$lnL, OU_RS$opt$lnL, EB_RS$opt$lnL)
kable(aic_RS)
library(knitr)
aic_HWI <- aicw(mods)
BM_RS <- fitContinuous(phy = furnariidaeTree, # phylogeny
dat = log(rangeSize), # trait
model = "BM") # evolutionary model
OU_RS <- fitContinuous(phy = furnariidaeTree,
dat = log(rangeSize),
model = "OU")
EB_RS <- fitContinuous(phy = furnariidaeTree,
dat = log(rangeSize),
model = "EB")
# Vector of models
mods_RS <- c(BM_RS$opt$aicc, OU_RS$opt$aicc, EB_RS$opt$aicc)
# rename the models
names(mods_RS) <- c("BM", "OU", "EB")
# Run AIC weights
aic_RS <- aicw(mods_RS)
names(aic_RS)[1] <- "AIC"
aic_RS$lnL <- c(BM_RS$opt$lnL, OU_RS$opt$lnL, EB_RS$opt$lnL)
kable(aic_RS)
