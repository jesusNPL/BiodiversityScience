#filter(region_wb == "North America")
filter(admin == "United States of America")
#| eval: false
map_US <- map_data('world')[map_data('world')$region == "USA", ]
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'lightgray', fill = 'lightgray') +
geom_point(data = occ_quemin,
aes(x = decimalLongitude, y = decimalLatitude),
color = "darkgray", alpha = 0.5) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
#| eval: false
map_US <- map_data('world')[map_data('world')$region == "USA", ]
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'lightgray', fill = 'lightgray') +
geom_point(data = occ_quemin,
aes(x = decimalLongitude, y = decimalLatitude),
color = "darkgray", alpha = 0.9) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
#| eval: false
map_US <- map_data('world')[map_data('world')$region == "USA", ]
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'lightgray', fill = 'lightgray') +
geom_point(data = occ_quemin,
aes(x = decimalLongitude, y = decimalLatitude),
color = "darkgray", alpha = 0.9) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
#| eval: false
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "darkgray", alpha = 0.9) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
#| eval: false
quemin_thinned <- thin(
loc.data =  occ_quemin_clean,
verbose = FALSE,
long.col = "decimalLongitude",
lat.col = "decimalLatitude",
spec.col = "species",
thin.par = 2, # points have at least a minimum distance of 2 km from each other
reps = 10,
locs.thinned.list.return = TRUE,
write.files = FALSE,
out.dir = "data/OCC/")
quemin_thinned <- as.data.frame(quemin_thinned[[10]])
quemin_thinned$species <- "Quercus_minima"
#| eval: false
glimpse(quemin_thinned)
#| eval: false
quemin_thinned_sf <- st_as_sf(quemin_thinned,
coords = c("Longitude", "Latitude"),
crs = 4326)
# The below code is using R base. We will use this object for the modelling part
quemin_thinned_spt <- SpatialPointsDataFrame(coords = quemin_thinned[, 1:2],
data = quemin_thinned,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
#| eval: false
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "blue", alpha = 0.5) +
geom_sf(data = quemin_thinned_sf, color = "red", alpha = 0.3) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
#| eval: false
save(occ_quemin, quemin_spt, quemin_thinned_sf, quemin_thinned,
file = "data/OCC/quemin_OCC_processed.RData")
rm(gbif_data, occ_quemin, quemin_spt)
#| eval: false
biosNames <- list.files("data/wc2.1_10m/",
pattern = "tif$")
# Please double check your folder path. You may need to change "wc10" to "bio_10m_bil"
bios2 <- rast(paste0("data/wc2.1_10m/", # folder directory
biosNames)) # file names
#| eval: false
names(bios)
#| eval: false
biosNames <- list.files("data/wc2.1_10m/",
pattern = "tif$")
# Please double check your folder path. You may need to change "wc10" to "bio_10m_bil"
bios <- rast(paste0("data/wc2.1_10m/", # folder directory
biosNames)) # file names
#| eval: false
names(bios)
str(bios[[1]])
#| eval: false
plot(c(bios[[1]], bios[[12]]))
#| eval: false
USpoly_spt <- as(USpoly, "Spatial") # used as extent
plot(USpoly_spt)
#| eval: false
bios_US <- crop(bios, USpoly, mask = TRUE)
#| eval: false
plot(bios_US[[1]]) # mean annual temperature
plot(quemin_thinned_spt, col = "red", pch = 16, add = TRUE) # add occurrence records
plot(USpoly_spt, lwd = 2, lty = 2, add = TRUE) # add country borders
#| eval: false
### Species specific accessible area
bb <- bbox(quemin_thinned_spt) # bounding box
ex <- ext(c(bb[1]-3, bb[3]+3, bb[2]-3, bb[4]+3)) # bounding box + 300 km
pex <- as.polygons(ex, crs = crs(bios_US)) #as(ex, 'SpatialPolygons') # transform to polygon
#crs(pex) <- crs(bios_US) # use the geographical reference of the bioclimatic variables
crs(USpoly_spt) <- crs(bios_US)
out <- terra::crop(USpoly_spt, as(pex, 'Spatial'), byid = FALSE) # use NAs to eliminate areas on the sea
#| eval: false
plot(bios_US[[1]])
plot(pex, add = TRUE, lty = 2)
plot(out, add = TRUE, lwd = 2)
#| eval: false
bios_spp <- crop(bios, out, mask = TRUE)
# plot the results
plot(bios_spp[[1]])
#plot(quemin_thinned_spt, add = TRUE, col = "red", pch = 16)
plot(USpoly_spt, add = TRUE, lty = 2)
#| eval: false
set.seed(12345) # Random Number Generation to obtain the same result
# Generate the data
absence <- dismo::randomPoints(mask = as(bios_spp[[1]], "Raster"), # transform spatraster to raster
n = round(nrow(quemin_thinned)*2, 0), # number of pseudoabsences
p = quemin_thinned_spt, # presence object
ext = c(bb[1]-3, bb[3]+3, bb[2]-3, bb[4]+3) # extent
)
#| eval: false
# Presences
presence <- data.frame(quemin_thinned) # presence data
# Pseudoabsences
absence <- data.frame(absence) # pseudoabsence data
absence$species <- "Quercus_minima"
names(absence) <- names(presence)
presence$Occurrence <- 1 # presence data
absence$Occurrence <- 0 # pseudoabsence data
quemin <- rbind(presence, absence) # combine both information
#| eval: false
plot(bios_spp[[1]])
plot(quemin_sp[quemin_sp$Occurrence == 1, ], col = "lightblue", add = TRUE, pch = 16)
#| eval: false
quemin_sp <- quemin
coordinates(quemin_sp) <- ~ Longitude + Latitude
crs(quemin_sp) <- crs(bios_spp)
quemin_sp
quemin_sf <- st_as_sf(quemin,
coords = c("Longitude", "Latitude"),
crs = crs(bios_spp))
#| eval: false
plot(bios_spp[[1]])
plot(quemin_sp[quemin_sp$Occurrence == 1, ], col = "lightblue", add = TRUE, pch = 16)
points(quemin_sp[quemin_sp$Occurrence == 0, ], col = "red", pch = 16)
#| eval: false
save(presence, absence, quemin, file = "Data/OCC/quemin_PresAbs.RData")
save(bb, e, USpoly_spt, out, p, file = "Data/Envi/accessible_area_quemin.RData")
#| eval: false
save(presence, absence, quemin, file = "Data/OCC/quemin_PresAbs.RData")
save(bb, ex, USpoly_spt, out, pex, file = "Data/Envi/accessible_area_quemin.RData")
#| eval: false
save(presence, absence, quemin, file = "data/OCC/quemin_PresAbs.RData")
save(bb, ex, USpoly_spt, out, pex, file = "data/accessible_area_quemin.RData")
rm(absence, presence, bios, ex, out, pex, bb)
#| eval: false
## extract variables
quemin_bios <- data.frame(terra::extract(bios_spp, quemin_sf))
## Combine coordinates and climate data
quemin_bios <- cbind(data.frame(quemin), quemin_bios)
## Remove NAs
quemin_bios <- quemin_bios[complete.cases(quemin_bios), ]
quemin_bios <- na.omit(quemin_bios)
glimpse(quemin_bios)
#| eval: false
cor_mat <- cor(quemin_bios[, c(6:24)], method = 'spearman')
#| eval: false
corrplot::corrplot.mixed(cor_mat,
tl.pos = "lt",
tl.cex = 0.5,
number.cex = 0.5,
addCoefasPercent = TRUE,
mar = c(0, 0, 1, 0))
#| eval: false
#source("R-Functions/select07_mod.R")
source("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2021/R-Functions/select07_mod.R")
# Run select07()
covar_sel <- select07_v2(X = quemin_bios[, -c(1:5)], # only predictors data
y = quemin_bios$Occurrence, # presence-absence data
threshold = 0.7) # here you can change the threshold for one
#| eval: false
# Run select07()
covar_sel <- select07_v2(X = quemin_bios[, -c(1:5)], # only predictors data
y = quemin_bios$Occurrence, # presence-absence data
threshold = 0.7) # here you can change the threshold for one
# Check out the structure of the resulting object:
str(covar_sel)
#| eval: false
# Run select07()
covar_sel <- select07_v2(X = quemin_bios[, -c(1:5)], # only predictors data
y = quemin_bios$Occurrence, # presence-absence data
threshold = 0.7) # here you can change the threshold for one
# Check out the structure of the resulting object:
str(covar_sel)
#| eval: false
covar_sel$AIC
covar_sel$cor_mat
covar_sel$pred_sel
#| eval: false
preds <- covar_sel$pred_sel
preds
#| eval: false
preds <- covar_sel$pred_sel
preds
#| eval: false
bios_quemin_sel <- bios_spp[[preds]]
plot(bios_quemin_sel)
?scale
#| eval: false
quemin_bios_sel <- quemin_bios %>%
select(Occurrence, all_of(preds))
quemin_bios_sel[, 2:8] <- scale(quemin_bios_sel[, 2:8])
#| eval: false
set.seed(12345)
index <- sample.int(nrow(quemin_bios_sel), 400) # 400 points or 0.33% of the data
## Testing data
testing <- quemin_bios_sel[index, ]
## Data for training our model
training <- quemin_bios_sel[-index, ]
#| eval: false
library(cito)
model <- dnn(Occurrence ~.,
data = training,
batchsize = 100L,
lr = 0.05,
#lambda = 0.001,
#alpha = 1.0,
validation = 0.33,
loss = "binomial",
bootstrap = 20L,
verbose = FALSE)
summary(model)
#| eval: false
library(cito)
quemin_ENM <- dnn(Occurrence ~.,
data = training,
batchsize = 100L,
lr = 0.05,
#lambda = 0.001,
#alpha = 1.0,
validation = 0.33,
loss = "binomial",
bootstrap = 20L,
verbose = FALSE)
summary(quemin_ENM)
quemin_ENM_pred <- predict(model,
newdata = testing,
reduce = "none")
dim(quemin_ENM_pred)
plot(quemin_ENM)
#| eval: false
AUCs <- sapply(1:20, function(i) Metrics::auc(testing$Occurrence, predictions[i,,]))
#| eval: false
AUCs <- sapply(1:20, function(i) Metrics::auc(testing$Occurrence, quemin_ENM_pred[i,,]))
hist(AUCs,
xlim = c(0, 1),
main = "AUC of bootstrap model",
xlab = "AUC")
AUCs
range(AUCs)
round(range(AUCs), 3)
#| eval: false
AUCs <- sapply(1:20, function(i) Metrics::auc(testing$Occurrence, quemin_ENM_pred[i,,]))
hist(AUCs,
xlim = c(0.7, 1),
main = "AUC of bootstrap model",
xlab = "AUC")
#| eval: false
quemin_Response <- summary(quemin_ENM)
quemin_Response
#| eval: false
library(cito)
quemin_DNN <- dnn(Occurrence ~.,
data = training,
batchsize = 100L,
lr = 0.05,
#lambda = 0.001,
#alpha = 1.0,
validation = 0.33,
loss = "binomial",
bootstrap = 20L,
verbose = FALSE)
summary(quemin_DNN)
plot(quemin_DNN)
#| eval: false
quemin_DNN_pred <- predict(quemin_DNN,
newdata = testing,
reduce = "none")
dim(quemin_DNN_pred)
#| eval: false
AUCs <- sapply(1:20, function(i) Metrics::auc(testing$Occurrence, quemin_DNN_pred[i,,]))
hist(AUCs,
xlim = c(0.7, 1),
main = "AUC of bootstrap model",
xlab = "AUC")
#| eval: false
quemin_Response <- summary(quemin_DNN)
quemin_Response
#| eval: false
## Scale the predictors
bios_quemin_sel_scale <- scale(bios_quemin_sel)
## Predict the Grinnellian niche for Quercus minima
quemin_ENM <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun,
na.rm = TRUE)
#| eval: false
## mean prediction
customPredictFun <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, mean)[, 1])
}
## standar deviation or uncertainty associated to the prediction
customPredictFun_sd <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, sd)[, 1])
}
#| eval: false
## Scale the predictors
bios_quemin_sel_scale <- scale(bios_quemin_sel)
## Predict the Grinnellian niche for Quercus minima
quemin_ENM <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun,
na.rm = TRUE)
#| eval: false
library(rasterVis)
library(RColorBrewer)
mapTheme <- rasterTheme(region = rev(brewer.pal(11, "Spectral")),
layout.widths = list(right.padding = 10),
axis.line = list(col = "transparent"),
tick = list(col = 'transparent'))
levelplot(predictions,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = TRUE),
y = list(draw = TRUE)),
zlim = c(0, 1))
#| eval: false
library(rasterVis)
library(RColorBrewer)
mapTheme <- rasterTheme(region = rev(brewer.pal(11, "Spectral")),
layout.widths = list(right.padding = 10),
axis.line = list(col = "transparent"),
tick = list(col = 'transparent'))
levelplot(quemin_ENM,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = TRUE),
y = list(draw = TRUE)),
zlim = c(0, 1))
#| eval: false
levelplot(quemin_ENM_uncertainty,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = TRUE),
y = list(draw = TRUE)),
zlim = c(0, 1))
#| eval: false
quemin_ENM_uncertainty <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun_sd,
na.rm = TRUE)
#| eval: false
levelplot(quemin_ENM_uncertainty,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = TRUE),
y = list(draw = TRUE)),
zlim = c(0, 1))
?writeRaster
#| eval: false
dir.create("results")
dir.create("results/ENM")
# save the predictions
writeRaster(quemin_ENM,
filename = "results/ENM/quemin_ENM.tif",
overwrite = TRUE)
# save the uncertainty prediction
writeRaster(quemin_ENM_uncertainty,
filename = "results/ENM/quemin_ENM_uncertainty.tif",
overwrite = TRUE)
#| eval: false
apply(predict(model, data, reduce = "none"), 2:3, mean)[, 1]
meanPred <- apply(as.data.frame.array(quemin_DNN_pred), MARGIN = 2, FUN = mean)
sdPred <- apply(as.data.frame.array(quemin_DNN_pred), MARGIN = 2, FUN = sd)
## Create a prediction object
predOBJ <- ROCR::prediction(meanPred, testing$Occurrence)
## Get global AUC
quemin_AUC <- performance(predOBJ, "auc")@y.values[[1]]
quemin_AUC
## Get global AUC
quemin_AUC <- performance(predOBJ, "auc")@y.values[[1]]
## Plot AUC
ROCdf <- performance(predOBJ, "tpr", "fpr")
ROCdf <- data.frame(fpr = rocdf@x.values[[1]],
tpr = rocdf@y.values[[1]])
ROCdf <- data.frame(fpr = ROCdf@x.values[[1]],
tpr = ROCdf@y.values[[1]])
ROCdf %>%
ggplot(aes(x = fpr, y = tpr)) +
geom_line(linewidth = 2) +
geom_abline(intercept = 0, slope = 1, col = 'red') +
ggtitle('Receiver-operator curve') +
xlab('False positive rate') +
ylab('True positive rate') +
theme_classic()
ROCdf %>%
ggplot(aes(x = fpr, y = tpr)) +
geom_line(linewidth = 2, color = "darkgray") +
geom_abline(intercept = 0, slope = 1, color = 'red', linewidth = 2) +
ggtitle('Receiver-operator curve') +
xlab('False positive rate') +
ylab('True positive rate') +
theme_classic()
quemin_PERF <- ROCR::performance(predOBJ, "sens", "spec")
PERF_list <- (quemin_PERF@x.values[[1]] + quemin_PERF@y.values[[1]] - 1)
data.frame(alpha = quemin_PERF@alpha.values[[1]], tss = PERF_list)
PERF_df <- data.frame(alpha = quemin_PERF@alpha.values[[1]], tss = PERF_list)
min(PERF_df$alpha[which(PERF_df$tss == max(PERF_df$tss))])
round(min(PERF_df$alpha[which(PERF_df$tss == max(PERF_df$tss))]), 2)
quemin_TSS <- PERF_df[which(PERF_df$alpha == quemin_threshold), 'tss']
## Calculate Threshold
quemin_threshold <- min(PERF_df$alpha[which(PERF_df$tss == max(PERF_df$tss))])
quemin_TSS <- PERF_df[which(PERF_df$alpha == quemin_threshold), 'tss']
#| eval: false
## Get sensitivity and specificity
quemin_PERF <- ROCR::performance(predOBJ, "sens", "spec")
PERF_list <- (quemin_PERF@x.values[[1]] + quemin_PERF@y.values[[1]] - 1)
PERF_df <- data.frame(alpha = quemin_PERF@alpha.values[[1]], tss = PERF_list)
## Calculate Threshold
quemin_threshold <- min(PERF_df$alpha[which(PERF_df$tss == max(PERF_df$tss))])
## Calculate True skill statistics (TSS)
quemin_TSS <- PERF_df[which(PERF_df$alpha == quemin_threshold), 'tss']
#| eval: false
quemin_SDM <- quemin_ENM
# reclassify our ensemble prediction
quemin_SDM[] <- ifelse(quemin_ENM[] >= quemin_threshold, 1, 0)
#| eval: false
plot(quemin_SDM)
plot(countriesCoarse, add = TRUE)
#| eval: false
dir.create("results/SDM")
writeRaster(quemin_SDM,
filename = "results/SDM/quemin_SDM",
overwrite = TRUE)
#| eval: false
dir.create("results/SDM")
writeRaster(quemin_SDM,
filename = "results/SDM/quemin_SDM.tif",
overwrite = TRUE)
#| eval: false
if (!("cito" %in% installed.packages())) {
install.packages("cito")
}
