#install torch
if(!torch_is_installed()) install_torch()
#| eval: false
if (!("cito" %in% installed.packages())) {
install.packages("cito")
}
#| eval: false
sapply(packages, require, character.only = TRUE)
library(tidyverse)
#| eval: false
spp <- c("Quercus virginiana", "Quercus minima", "Quercus alba", "Quercus fusiformis", "Quercus oleoides")
load("data/OCC/oaks_raw_occ.RDATA")
setwd("Documents/GitHub/BiodiversityScience/Spring2024/Lab_5_ENM_SDM/")
load("data/OCC/oaks_raw_occ.RDATA")
#| eval: false
#gbif_data
# if, for any species, "Records found" is larger than "Records returned", you need to increase the 'limit' argument above -- see help(occ_data) for options and limitations
# check how the data are organized:
names(gbif_data)
# metadata of the object #2
names(gbif_data[[2]]$meta)
# the data
names(gbif_data[[2]]$data)
#| eval: false
# get the columns that matter for mapping and cleaning the occurrence data:
occ_quemin <- gbif_data[[2]]$data %>%
dplyr::select(species, decimalLongitude,
decimalLatitude, countryCode, individualCount,
gbifID, family, taxonRank, coordinateUncertaintyInMeters,
year, basisOfRecord, institutionCode, datasetName)
occ_quemin
#| eval: false
glimpse(occ_quemin)
#| eval: false
occ_quemin <- occ_quemin %>%
filter(!is.na(decimalLongitude & !is.na(decimalLatitude)))
occ_quemin
#| eval: false
#convert country code from ISO2c to ISO3c
occ_quemin$countryCode <- countrycode::countrycode(occ_quemin$countryCode,
origin = 'iso2c',
destination = 'iso3c')
#flag problems
occ_quemin <- data.frame(occ_quemin)
occ_quemin_flag <- clean_coordinates(x = occ_quemin,
lon = "decimalLongitude",
lat = "decimalLatitude",
countries = "countryCode",
species = "species",
tests = c("capitals", "centroids",
"equal", "zeros", "countries")) # most test are on by default
#| eval: false
summary(occ_quemin_flag)
#| eval: false
plot(occ_quemin_flag, lon = "decimalLongitude", lat = "decimalLatitude")
#| eval: false
occ_quemin_clean <- occ_quemin_flag %>%
filter(.summary == TRUE)
occ_quemin_clean
#| eval: false
plot(occ_quemin_clean, lon = "decimalLongitude", lat = "decimalLatitude")
#| eval: false
quemin_spt <- st_as_sf(occ_quemin_clean,
coords = c("decimalLongitude", "decimalLatitude"),
crs = 4326) #%>%
#st_cast("MULTIPOINT")
# explore the data
glimpse(quemin_spt)
#| eval: false
sf_use_s2(FALSE)
# world map
worldMap <- rnaturalearth::ne_countries(scale = "medium",
type = "countries",
returnclass = "sf")
# country subset
USpoly <- worldMap %>%
#filter(region_wb == "North America")
filter(admin == "United States of America")
#| eval: false
map_US <- map_data('world')[map_data('world')$region == "USA", ]
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'lightgray', fill = 'lightgray', alpha = 0.5) +
geom_point(data = occ_quemin,
aes(x = decimalLongitude, y = decimalLatitude),
color = "darkgray", alpha = 0.9) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
#| eval: false
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3', alpha = 0.5) +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "darkgray", alpha = 0.9) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
#| eval: false
quemin_thinned <- thin(
loc.data =  occ_quemin_clean,
verbose = FALSE,
long.col = "decimalLongitude",
lat.col = "decimalLatitude",
spec.col = "species",
thin.par = 2, # points have at least a minimum distance of 2 km from each other
reps = 10, # number of repetitions
locs.thinned.list.return = TRUE,
write.files = FALSE,
out.dir = "data/OCC/")
quemin_thinned <- as.data.frame(quemin_thinned[[10]])
quemin_thinned$species <- "Quercus_minima"
#| eval: false
glimpse(quemin_thinned)
#| eval: false
quemin_thinned_sf <- st_as_sf(quemin_thinned,
coords = c("Longitude", "Latitude"),
crs = 4326)
# The below code is using R base. We will use this object for the modelling part
quemin_thinned_spt <- SpatialPointsDataFrame(coords = quemin_thinned[, 1:2],
data = quemin_thinned,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
#| eval: false
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "blue", alpha = 0.5) +
geom_sf(data = quemin_thinned_sf, color = "red", alpha = 0.3) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
#| eval: false
save(occ_quemin, quemin_spt, quemin_thinned_sf, quemin_thinned,
file = "data/OCC/quemin_OCC_processed.RData")
rm(gbif_data, occ_quemin, quemin_spt)
#| eval: false
biosNames <- list.files("data/wc2.1_10m/",
pattern = "tif$")
# Please double check your folder path.
bios <- rast(paste0("data/wc2.1_10m/", # folder directory
biosNames)) # file names
#| eval: false
names(bios)
str(bios[[1]])
#| eval: false
plot(c(bios[[1]], bios[[12]]))
#| eval: false
USpoly_spt <- as(USpoly, "Spatial") # used as extent
plot(USpoly_spt)
#| eval: false
bios_US <- crop(bios, USpoly, mask = TRUE)
#| eval: false
plot(bios_US[[1]]) # mean annual temperature
plot(quemin_thinned_spt, col = "red", pch = 16, add = TRUE) # add occurrence records
plot(USpoly_spt, lwd = 2, lty = 2, add = TRUE) # add country borders
#| eval: false
### Species specific accessible area
bb <- bbox(quemin_thinned_spt) # bounding box
ex <- ext(c(bb[1]-3, bb[3]+3, bb[2]-3, bb[4]+3)) # bounding box + 300 km
pex <- as.polygons(ex, crs = crs(bios_US)) #as(ex, 'SpatialPolygons') # transform to polygon
#crs(pex) <- crs(bios_US) # use the geographical reference of the bioclimatic variables
crs(USpoly_spt) <- crs(bios_US)
out <- terra::crop(USpoly_spt, as(pex, 'Spatial'), byid = FALSE) # use NAs to eliminate areas on the sea
#| eval: false
plot(bios_US[[1]])
plot(pex, add = TRUE, lty = 2)
plot(out, add = TRUE, lwd = 2)
#| eval: false
bios_spp <- terra::crop(bios, out, mask = TRUE)
#bios_spp <- terra::mask(bios_spp, vect(out))
# plot the results
plot(bios_spp[[1]])
#plot(quemin_thinned_spt, add = TRUE, col = "red", pch = 16)
plot(USpoly_spt, add = TRUE, lty = 2)
#| eval: false
set.seed(12345) # Random Number Generation to obtain the same result
# Generate the data
absence <- dismo::randomPoints(mask = as(bios_spp[[1]], "Raster"), # transform spatraster to raster
n = round(nrow(quemin_thinned)*2, 0), # number of pseudoabsences
p = quemin_thinned_spt, # presence object
ext = c(bb[1]-3, bb[3]+3, bb[2]-3, bb[4]+3) # extent
)
#| eval: false
# Presences
presence <- data.frame(quemin_thinned) # presence data
# Pseudoabsences
absence <- data.frame(absence) # pseudoabsence data
absence$species <- "Quercus_minima"
names(absence) <- names(presence)
presence$Occurrence <- 1 # presence data
absence$Occurrence <- 0 # pseudoabsence data
quemin <- rbind(presence, absence) # combine both information
#| eval: false
quemin_sp <- quemin
coordinates(quemin_sp) <- ~ Longitude + Latitude
crs(quemin_sp) <- crs(bios_spp)
quemin_sp
quemin_sf <- st_as_sf(quemin,
coords = c("Longitude", "Latitude"),
crs = crs(bios_spp))
#| eval: false
plot(bios_spp[[1]])
plot(quemin_sp[quemin_sp$Occurrence == 1, ], col = "red", add = TRUE, pch = 16) # presence
points(quemin_sp[quemin_sp$Occurrence == 0, ], col = "blue", pch = 16) # absence
#| eval: false
save(presence, absence, quemin, file = "data/OCC/quemin_PresAbs.RData")
save(bb, ex, USpoly_spt, out, pex, file = "data/accessible_area_quemin.RData")
rm(absence, presence, bios, ex, out, pex, bb)
#| eval: false
## extract variables
quemin_bios <- data.frame(terra::extract(bios_spp, quemin_sf))
## Combine coordinates and climate data
quemin_bios <- cbind(data.frame(quemin), quemin_bios)
## Remove NAs
quemin_bios <- quemin_bios[complete.cases(quemin_bios), ]
quemin_bios <- na.omit(quemin_bios)
glimpse(quemin_bios)
#| eval: false
cor_mat <- cor(quemin_bios[, c(6:24)], method = 'spearman')
#| eval: false
corrplot::corrplot.mixed(cor_mat,
tl.pos = "lt",
tl.cex = 0.5,
number.cex = 0.5,
addCoefasPercent = TRUE,
mar = c(0, 0, 1, 0))
#| eval: false
#source("R-Functions/select07_mod.R")
source("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2021/R-Functions/select07_mod.R")
# Run select07()
covar_sel <- select07_v2(X = quemin_bios[, -c(1:5)], # only predictors data
y = quemin_bios$Occurrence, # presence-absence data
threshold = 0.7) # here you can change the threshold for one
#| eval: false
# Check out the structure of the resulting object:
str(covar_sel)
#| eval: false
covar_sel$AIC
covar_sel$cor_mat
covar_sel$pred_sel
#| eval: false
preds <- covar_sel$pred_sel
preds
#| eval: false
bios_quemin_sel <- bios_spp[[preds]]
plot(bios_quemin_sel)
#| eval: false
quemin_bios_sel <- quemin_bios %>%
select(Occurrence, all_of(preds))
quemin_bios_sel[, 2:8] <- scale(quemin_bios_sel[, 2:8])
#| eval: false
set.seed(12345)
index <- sample.int(nrow(quemin_bios_sel), 400) # 400 points or 0.33% of the data
## Testing data
testing <- quemin_bios_sel[index, ]
## Data for training our model
training <- quemin_bios_sel[-index, ]
#| eval: false
library(cito)
#| eval: false
quemin_DNN <- dnn(Occurrence ~., # formula
data = training, # data for training
batchsize = 150L,
epochs = 100L,
lr = 0.05,
#lambda = 0.001,
#alpha = 1.0,
validation = 0.33,
loss = "binomial", # model
#early_stopping = 15,
bootstrap = 20L, # number of bootstraps set to 20
verbose = FALSE)
#| eval: false
analyze_training(quemin_DNN)
#| eval: false
quemin_DNN_pred <- predict(quemin_DNN,
newdata = testing,
reduce = "none")
dim(quemin_DNN_pred)
#| eval: false
AUCs <- sapply(1:20, function(i) Metrics::auc(testing$Occurrence, quemin_DNN_pred[i,,]))
hist(AUCs,
xlim = c(0.7, 1),
main = "AUC of bootstrap model",
xlab = "AUC")
range(AUCs)
#| eval: false
quemin_Response <- summary(quemin_DNN)
quemin_Response
ALE(model = quemin_DNN, variable = preds[1])
ALE(model = quemin_DNN, variable = preds[2])
#| eval: false
ALE(model = quemin_DNN, variable = preds[1])
ALE(model = quemin_DNN, variable = preds[2])
ALE(model = quemin_DNN, variable = preds[3])
ALE(model = quemin_DNN, variable = preds[4])
ALE(model = quemin_DNN, variable = preds[5])
ALE(model = quemin_DNN, variable = preds[6])
ALE(model = quemin_DNN, variable = preds[7])
?ALE
#| eval: false
## mean prediction
customPredictFun <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, mean)[, 1])
}
## standar deviation or uncertainty associated to the prediction
customPredictFun_sd <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, sd)[, 1])
}
#| eval: false
## Scale the predictors
bios_quemin_sel_scale <- terra::scale(bios_quemin_sel)
## Predict the Grinnellian niche for Quercus minima
quemin_ENM <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun,
na.rm = TRUE)
#| eval: false
library(rasterVis)
library(RColorBrewer)
mapTheme <- rasterTheme(region = rev(brewer.pal(11, "Spectral")),
layout.widths = list(right.padding = 10),
axis.line = list(col = "transparent"),
tick = list(col = 'transparent'))
levelplot(quemin_ENM,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = TRUE),
y = list(draw = TRUE)),
zlim = c(0, 1))
quemin_ENM
#| eval: false
## mean prediction
customPredictFun <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, mean)[, 1])
}
## standar deviation or uncertainty associated to the prediction
customPredictFun_sd <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, sd)[, 1])
}
bios_quemin_sel_scale
## Predict the Grinnellian niche for Quercus minima
quemin_ENM <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun,
na.rm = TRUE)
quemin_ENM
#| eval: false
quemin_ENM_uncertainty <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun_sd,
na.rm = TRUE)
#| eval: false
levelplot(quemin_ENM_uncertainty,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = TRUE),
y = list(draw = TRUE)),
zlim = c(0, 1))
plot(bios_quemin_sel_scale)
## Scale the predictors
bios_quemin_sel_scale <- terra::scale(bios_quemin_sel)
## Predict the Grinnellian niche for Quercus minima
quemin_ENM <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun,
na.rm = TRUE)
quemin_ENM
#| eval: false
## Get mean and sd predictions
meanPred <- apply(as.data.frame.array(quemin_DNN_pred), MARGIN = 2, FUN = mean)
sdPred <- apply(as.data.frame.array(quemin_DNN_pred), MARGIN = 2, FUN = sd)
## Create a prediction object
predOBJ <- ROCR::prediction(meanPred, testing$Occurrence)
## Get global AUC
quemin_AUC <- performance(predOBJ, "auc")@y.values[[1]]
## Plot AUC
ROCdf <- performance(predOBJ, "tpr", "fpr")
ROCdf <- data.frame(fpr = ROCdf@x.values[[1]],
tpr = ROCdf@y.values[[1]])
ROCdf %>%
ggplot(aes(x = fpr, y = tpr)) +
geom_line(linewidth = 2, color = "darkgray") +
geom_abline(intercept = 0, slope = 1, color = 'red', linewidth = 2) +
ggtitle('Receiver-operator curve') +
xlab('False positive rate') +
ylab('True positive rate') +
theme_classic()
#| eval: false
## Get sensitivity and specificity
quemin_PERF <- ROCR::performance(predOBJ, "sens", "spec")
PERF_list <- (quemin_PERF@x.values[[1]] + quemin_PERF@y.values[[1]] - 1)
PERF_df <- data.frame(alpha = quemin_PERF@alpha.values[[1]], tss = PERF_list)
## Calculate Threshold
quemin_threshold <- min(PERF_df$alpha[which(PERF_df$tss == max(PERF_df$tss))])
## Calculate True skill statistics (TSS)
quemin_TSS <- PERF_df[which(PERF_df$alpha == quemin_threshold), 'tss']
quemin_threshold
#| eval: false
quemin_SDM <- quemin_ENM
# reclassify our ensemble prediction
quemin_SDM[] <- ifelse(quemin_ENM[] >= quemin_threshold, 1, 0)
#| eval: false
plot(quemin_SDM)
plot(countriesCoarse, add = TRUE)
quemin_TSS
#| eval: false
quemin_DNN <- dnn(Occurrence ~., # formula
data = training, # data for training
batchsize = 150L,
epochs = 100L,
lr = 0.05,
#lambda = 0.001,
#alpha = 1.0,
validation = 0.33,
loss = "binomial", # model
#early_stopping = 15,
#bootstrap = 20L, # number of bootstraps set to 20
verbose = FALSE)
#| eval: false
plot(quemin_DNN)
#| eval: false
## mean prediction
customPredictFun <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, mean)[, 1])
}
## standar deviation or uncertainty associated to the prediction
customPredictFun_sd <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, sd)[, 1])
}
#| eval: false
## Scale the predictors
bios_quemin_sel_scale <- terra::scale(bios_quemin_sel)
## Predict the Grinnellian niche for Quercus minima
quemin_ENM <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun,
na.rm = TRUE)
predict(model = quemin_DNN, data = bios_quemin_sel_scale,, reduce = "none")
predict(model = quemin_DNN, data = bios_quemin_sel_scale, reduce = "none")
#| eval: false
quemin_DNN <- dnn(Occurrence ~., # formula
data = training, # data for training
batchsize = 150L,
epochs = 100L,
lr = 0.05,
#lambda = 0.001,
#alpha = 1.0,
validation = 0.33,
loss = "binomial", # model
#early_stopping = 15,
bootstrap = 20L, # number of bootstraps set to 20
verbose = FALSE)
#| eval: false
## mean prediction
customPredictFun <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, mean)[, 1])
}
## standar deviation or uncertainty associated to the prediction
customPredictFun_sd <- function(model, data) {
return(apply(predict(model, data, reduce = "none"), 2:3, sd)[, 1])
}
#| eval: false
## Scale the predictors
bios_quemin_sel_scale <- terra::scale(bios_quemin_sel)
## Predict the Grinnellian niche for Quercus minima
quemin_ENM <- terra::predict(object = bios_quemin_sel_scale,
model = quemin_DNN,
fun = customPredictFun,
na.rm = TRUE)
#| eval: false
library(rasterVis)
library(RColorBrewer)
mapTheme <- rasterTheme(region = rev(brewer.pal(11, "Spectral")),
layout.widths = list(right.padding = 10),
axis.line = list(col = "transparent"),
tick = list(col = 'transparent'))
levelplot(quemin_ENM,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = TRUE),
y = list(draw = TRUE)),
zlim = c(0, 1))
