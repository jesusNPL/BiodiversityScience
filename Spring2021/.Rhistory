nBands <- reflInfo$Dimensions[3]
# Extract or "slice" data for band 9 from the HDF5 file
b10 <- h5read(f, "/HARV/Reflectance/Reflectance_Data",
index = list(10, 1:nCols, 1:nRows))
# what type of object is b10?
class(b10)
# convert from array to matrix by selecting only the first band
b9 <- b9[1,,]
# convert from array to matrix by selecting only the first band
b10 <- b10[1,,]
# check it
class(b10)
# plot the image
image(b10)
# oh, that is hard to visually interpret.
# what happens if we plot a log of the data?
image(log(b10))
# there is NO data value in our raster - let's define it
myNoDataValue <- as.numeric(reflInfo$Data_Ignore_Value)
myNoDataValue
# set all values equal to -9999 to NA
b10[b10 == myNoDataValue] <- NA
# plot the image now
image(b10)
# We need to transpose x and y values in order for our
# final image to plot properly
b10 <- t(b10)
image(log(b10), main = "Transposed Image")
# Extract the EPSG from the h5 dataset
myEPSG <- h5read(f, "/HARV/Reflectance/Metadata/Coordinate_System/EPSG Code")
# convert the EPSG code to a CRS string
myCRS <- crs(paste0("+init=epsg:", myEPSG))
# define final raster with projection info
# note that capitalization will throw errors on a MAC.
# if UTM is all caps it might cause an error!
b10ras <- raster(b10, crs = myCRS)
# view the raster attributes
b10ras
image(log(b10ras),
xlab = "UTM Easting",
ylab = "UTM Northing",
main = "Properly Oriented Raster")
# Grab the UTM coordinates of the spatial extent
xMin <- reflInfo$Spatial_Extent_meters[1]
xMax <- reflInfo$Spatial_Extent_meters[2]
yMin <- reflInfo$Spatial_Extent_meters[3]
yMax <- reflInfo$Spatial_Extent_meters[4]
# define the extent (left, right, top, bottom)
rasExt <- extent(xMin, xMax, yMin, yMax)
# view the extent to make sure that it looks right
rasExt
# assign the spatial extent to the raster
extent(b10ras) <- rasExt
# look at raster attributes
b10ras
# let's change the colors of our raster and adjust the zlims
col <- terrain.colors(25)
image(b10ras,
xlab = "UTM Easting",
ylab = "UTM Northing",
main= "Raster w Custom Colors",
col = col,
zlim = c(0, 3000))
# write out the raster as a geotiff
writeRaster(b10ras,
file = "Data/NEON/DP3.30006.001/HARV_plot_001_band10.tif",
format = "GTiff",
overwrite = TRUE)
# create a list of the bands we want in our stack
rgb <- list(58, 34, 19) #list(58,34,19) when using full NEON hyperspectral dataset
# lapply tells R to apply the function to each element in the list
rgb_harv <- lapply(rgb, FUN = band2Raster, file = f,
noDataValue = myNoDataValue,
extent = rasExt,
CRS = myCRS)
band2Raster <- function(file, band, noDataValue, extent, CRS){
# first, read in the raster
out <- h5read(file,"/HARV/Reflectance/Reflectance_Data", index = list(band, NULL, NULL))
# Convert from array to matrix
out <- (out[1,,])
# transpose data to fix flipped row and column order
# depending upon how your data are formatted you might not have to perform this
# step.
out <- t(out)
# assign data ignore values to NA
# note, you might chose to assign values of 15000 to NA
out[out == myNoDataValue] <- NA
# turn the out object into a raster
outr <- raster(out, crs = CRS)
# assign the extents to the raster
extent(outr) <- extent
# return the raster object
return(outr)
}
# lapply tells R to apply the function to each element in the list
rgb_harv <- lapply(rgb, FUN = band2Raster, file = f,
noDataValue = myNoDataValue,
extent = rasExt,
CRS = myCRS)
# check out the properties or rgb_rast
# note that it displays properties of 3 rasters.
rgb_harv
# Create a raster stack from our list of rasters
rgb_harv_stack <- stack(rgb_rast)
# Create a raster stack from our list of rasters
rgb_harv_stack <- stack(rgb_harv)
rgb_harv_stack
# Create a list of band names
bandNames <- paste("Band_", unlist(rgb), sep = "")
# set the rasterStack's names equal to the list of bandNames created above
names(rgb_harv_stack) <- bandNames
# check properties of the raster list - note the band names
rgb_harv_stack
# scale the data as specified in the reflInfo$Scale Factor
rgb_harv_stack <- rgb_harv_stack/as.integer(reflInfo$Scale_Factor)
# plot one raster in the stack to make sure things look OK.
plot(rgb_harv_stack$Band_14, main = "Band 58")
# plot one raster in the stack to make sure things look OK.
plot(rgb_harv_stack$Band_58, main = "Band 58")
# Extract or "slice" data for band 9 from the HDF5 file
b34 <- h5read(f, "/HARV/Reflectance/Reflectance_Data",
index = list(34, 1:nCols, 1:nRows))
# what type of object is b34?
class(b34)
## [1] "array"
# convert from array to matrix by selecting only the first band
b34 <- b34[1,,]
# check it
class(b34)
# plot the image
image(b34)
# oh, that is hard to visually interpret.
# what happens if we plot a log of the data?
image(log(b34))
# there is NO data value in our raster - let's define it
myNoDataValue <- as.numeric(reflInfo$Data_Ignore_Value)
myNoDataValue
# set all values equal to -9999 to NA
b34[b34 == myNoDataValue] <- NA
# plot the image now
image(b34)
# We need to transpose x and y values in order for our
# final image to plot properly
b34 <- t(b34)
image(log(b34), main = "Transposed Image")
# Extract the EPSG from the h5 dataset
myEPSG <- h5read(f, "/HARV/Reflectance/Metadata/Coordinate_System/EPSG Code")
# convert the EPSG code to a CRS string
myCRS <- crs(paste0("+init=epsg:", myEPSG))
# define final raster with projection info
# note that capitalization will throw errors on a MAC.
# if UTM is all caps it might cause an error!
b34ras <- raster(b34, crs = myCRS)
# view the raster attributes
b34ras
image(log(b34ras),
xlab = "UTM Easting",
ylab = "UTM Northing",
main = "Properly Oriented Raster")
# assign the spatial extent to the raster
extent(b34ras) <- rasExt
# look at raster attributes
b10ras
# assign the spatial extent to the raster
extent(b34ras) <- rasExt
# look at raster attributes
b34ras
# write out the raster as a geotiff
writeRaster(b34ras,
file = "Data/NEON/DP3.30006.001/HARV_plot_001_band_34.tif",
format = "GTiff",
overwrite = TRUE)
# file: the hdf file
# band: the band you want to process
# noDataValue: values to be omitted
# extent: raster extent
# CRS: coordinates system
# returns: a matrix containing the reflectance data for the specific band
band2Raster <- function(file, band, noDataValue, extent, CRS){
# first, read in the raster
out <- h5read(file,"/HARV/Reflectance/Reflectance_Data", index = list(band, NULL, NULL))
# Convert from array to matrix
out <- (out[1,,])
# transpose data to fix flipped row and column order
# depending upon how your data are formatted you might not have to perform this
# step.
out <- t(out)
# assign data ignore values to NA
# note, you might chose to assign values of 15000 to NA
out[out == myNoDataValue] <- NA
# turn the out object into a raster
outr <- raster(out, crs = CRS)
# assign the extents to the raster
extent(outr) <- extent
# return the raster object
return(outr)
}
# create a 3 band RGB image
plotRGB(rgb_harv_stack,
r = 1, g = 2, b = 3,
stretch = "lin")
# write out final raster
# note: if you set overwrite to TRUE, then you will overwite or lose the older
# version of the tif file! Keep this in mind.
writeRaster(rgb_harv_stack, file = "Data/NEON/DP3.30006.001/HARV_plot_001_RGB.tif",
format = "GTiff", overwrite = TRUE)
# Calculate NDVI
# select bands to use in calculation (red, NIR)
ndvi_bands <- c(58, 90) #bands c(58, 90) in full NEON hyperspectral dataset
# create raster list and then a stack using those two bands
ndvi_harv <- lapply(ndvi_bands, FUN = band2Raster, file = f,
noDataValue = myNoDataValue,
extent = rasExt, CRS = myCRS)
ndvi_harv <- stack(ndvi_harv)
# make the names pretty
bandNDVINames <- paste("Band_", unlist(ndvi_bands), sep = "")
names(ndvi_harv) <- bandNDVINames
# view the properties of the new raster stack
ndvi_harv
#calculate NDVI
NDVI_func <- function(ras) {
(ras[,2] - ras[,1])/(ras[,2]+ras[,1])
}
ndvi_calc <- calc(ndvi_stack, fun = NDVI_func)
ndvi_calc <- calc(ndvi_harv, fun = NDVI_func)
plot(ndvi_calc, main = "NDVI for the NEON HARV Field Site")
# Now, play with breaks and colors to create a meaningful map
# add a color map with 4 colors
myCol <- rev(terrain.colors(4)) # use the 'rev()' function to put green as the highest NDVI value
# add breaks to the colormap, including lowest and highest values (4 breaks = 3 segments)
brk <- c(0, .25, .5, .75, 1)
# plot the image using breaks
plot(ndvi_calc, main = "NDVI for the NEON HARV Field Site", col = myCol, breaks = brk)
writeRaster(ndvi_calc, file = "Data/NEON/DP3.30006.001/HARV_plot_001_NDVI.tif",
format = "GTiff", overwrite = TRUE)
# extract all bands from a single pixel
aPixel <- h5read(f, "/HARV/Reflectance/Reflectance_Data", index = list(NULL, 100, 35))
# The line above generates a vector of reflectance values.
# Next, we reshape the data and turn them into a dataframe
b <- adply(aPixel, c(1))
# create clean data frame
aPixeldf <- b[2]
# add wavelength data to matrix
aPixeldf$Wavelength <- WL
head(aPixeldf)
# grab scale factor from the Reflectance attributes
scaleFact <- reflInfo$Scale_Factor
# add scaled data column to DF
aPixeldf$scaled <- (aPixeldf$V1/as.vector(scaleFact))
# make nice column names
names(aPixeldf) <- c('Reflectance', 'Wavelength', 'ScaledReflectance')
head(aPixeldf)
tail(aPixeldf)
ggplot(data = aPixeldf) +
geom_line(aes(x = Wavelength, y = ScaledReflectance)) +
xlab("Wavelength (nm)") +
ylab("Reflectance")
plotRGB(rgb_harv_stack,
r = 1, g = 2, b = 3,
stretch = "lin")
packages <- c("maptools", "rgdal", "raster", "neonUtilities", "rasterdiv",
"BiocManager", "dplyr", "tidyr", "ggplot2", "plyr", "reshape2")
sapply(packages, require, character.only = TRUE)
plotRGB(rgb_harv_stack,
r = 1, g = 2, b = 3,
stretch = "lin")
par(col = "red", cex = 3)
clk <- click(rgbStack, id = T, xy = T, cell = T,
type = "p", pch = 16, col = "magenta", col.lab = "red")
clk <- click(rgb_harv_stack, id = T, xy = T, cell = T,
type = "p", pch = 16, col = "magenta", col.lab = "red")
View(clk)
# convert raster cell number into row and column (used to extract spectral signature below)
clk$row <- clk$cell%/%nrow(rgb_harv_stack) + 1 # add 1 because R is 1-indexed
clk$col <- clk$cell%%ncol(rgb_harv_stack)
# create a new dataframe from the band wavelengths so that we can add
# the reflectance values for each cover type
Pixel_df <- as.data.frame(WL)
# loop through each of the cells that we selected
for(i in 1:length(clk$cell)){
# extract Spectra from a single pixel
aPixel <- h5read(f, "/HARV/Reflectance/Reflectance_Data",
index = list(NULL, clk$col[i], clk$row[i]))
# scale reflectance values from 0-1
aPixel <- aPixel/as.vector(scaleFact)
# reshape the data and turn into dataframe
b <- adply(aPixel, clk(1))
# rename the column that we just created
names(b)[2] <- paste0("Point_", i)
# add reflectance values for this pixel to our combined data.frame called Pixel_df
Pixel_df <- cbind(Pixel_df, b[2])
}
# loop through each of the cells that we selected
for(i in 1:length(clk$cell)){
# extract Spectra from a single pixel
aPixel <- h5read(f, "/HARV/Reflectance/Reflectance_Data",
index = list(NULL, clk$col[i], clk$row[i]))
# scale reflectance values from 0-1
aPixel <- aPixel/as.vector(scaleFact)
# reshape the data and turn into dataframe
b <- adply(aPixel, c(1))
# rename the column that we just created
names(b)[2] <- paste0("Point_", i)
# add reflectance values for this pixel to our combined data.frame called Pixel_df
Pixel_df <- cbind(Pixel_df, b[2])
}
Pixel_df
# Use the melt() function to reshape the dataframe into a format that ggplot prefers
Pixel.melt <- melt(Pixel_df, id.vars = "wavelengths", value.name = "Reflectance")
# Use the melt() function to reshape the dataframe into a format that ggplot prefers
Pixel.melt <- melt(Pixel_df, id.vars = "WL", value.name = "Reflectance")
## Warning in melt(Pixel_df, id.vars = "wavelengths", value.name = "Reflectance"): The melt
## generic in data.table has been passed a data.frame and will attempt to redirect to the
## relevant reshape2 method; please note that reshape2 is deprecated, and this redirection is
## now deprecated as well. To continue using melt methods from reshape2 while both libraries
## are attached, e.g. melt.list, you can prepend the namespace like reshape2::melt(Pixel_df).
## In the next version, this warning will become an error.
# Now, let's plot some spectral signatures!
ggplot() +
geom_line(data = Pixel.melt, mapping = aes(x = wavelengths,
y = Reflectance,
color = variable), lwd = 1.5) +
scale_colour_manual(values = c("green2", "green4", "grey50", "tan4", "blue3"),
labels = c("Field", "Tree", "Roof", "Soil", "Water"))+
labs(color = "Cover Type") +
ggtitle("Land cover spectral signatures") +
theme(plot.title = element_text(hjust = 0.5, size = 20)) +
xlab("Wavelength")
# Use the melt() function to reshape the dataframe into a format that ggplot prefers
Pixel.melt <- melt(Pixel_df, id.vars = "WL", value.name = "Reflectance")
## Warning in melt(Pixel_df, id.vars = "wavelengths", value.name = "Reflectance"): The melt
## generic in data.table has been passed a data.frame and will attempt to redirect to the
## relevant reshape2 method; please note that reshape2 is deprecated, and this redirection is
## now deprecated as well. To continue using melt methods from reshape2 while both libraries
## are attached, e.g. melt.list, you can prepend the namespace like reshape2::melt(Pixel_df).
## In the next version, this warning will become an error.
# Now, let's plot some spectral signatures!
ggplot() +
geom_line(data = Pixel.melt, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
scale_colour_manual(values = c("green2", "green4", "grey50", "tan4", "blue3"),
labels = c("Field", "Tree", "Roof", "Soil", "Water"))+
labs(color = "Cover Type") +
ggtitle("Land cover spectral signatures") +
theme(plot.title = element_text(hjust = 0.5, size = 20)) +
xlab("Wavelength")
plotRGB(rgb_harv_stack,
r = 1, g = 2, b = 3,
stretch = "lin")
# change plotting parameters to better see the points and numbers generated from clicking
par(col = "red", cex = 3)
# use the 'click' function
clk <- click(rgb_harv_stack, id = T, xy = T, cell = T,
type = "p", pch = 16, col = "magenta", col.lab = "red")
# convert raster cell number into row and column (used to extract spectral signature below)
clk$row <- clk$cell%/%nrow(rgb_harv_stack) + 1 # add 1 because R is 1-indexed
clk$col <- clk$cell%%ncol(rgb_harv_stack)
# create a new dataframe from the band wavelengths so that we can add
# the reflectance values for each cover type
Pixel_df <- as.data.frame(WL)
# loop through each of the cells that we selected
for(i in 1:length(clk$cell)){
# extract Spectra from a single pixel
aPixel <- h5read(f, "/HARV/Reflectance/Reflectance_Data",
index = list(NULL, clk$col[i], clk$row[i]))
# scale reflectance values from 0-1
aPixel <- aPixel/as.vector(scaleFact)
# reshape the data and turn into dataframe
b <- adply(aPixel, c(1))
# rename the column that we just created
names(b)[2] <- paste0("Point_", i)
# add reflectance values for this pixel to our combined data.frame called Pixel_df
Pixel_df <- cbind(Pixel_df, b[2])
}
# Use the melt() function to reshape the dataframe into a format that ggplot prefers
Pixel.melt <- melt(Pixel_df, id.vars = "WL", value.name = "Reflectance")
## Warning in melt(Pixel_df, id.vars = "wavelengths", value.name = "Reflectance"): The melt
## generic in data.table has been passed a data.frame and will attempt to redirect to the
## relevant reshape2 method; please note that reshape2 is deprecated, and this redirection is
## now deprecated as well. To continue using melt methods from reshape2 while both libraries
## are attached, e.g. melt.list, you can prepend the namespace like reshape2::melt(Pixel_df).
## In the next version, this warning will become an error.
# Now, let's plot some spectral signatures!
ggplot() +
geom_line(data = Pixel.melt, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
scale_colour_manual(values = c("green2", "green4", "green", "tan4", "blue3"),
labels = c("Forest1", "Forest2", "Forest3", "Anthropic", "Water"))+
labs(color = "Cover Type") +
ggtitle("Land cover spectral signatures") +
theme(plot.title = element_text(hjust = 0.5, size = 20)) +
xlab("Wavelength")
reflInfo$Band_Window_1_Nanometers
# grab Reflectance metadata (which contains absorption band limits)
reflMetadata <- h5readAttributes(f, "/HARV/Reflectance" )
ab1 <- reflMetadata$Band_Window_1_Nanometers
ab2 <- reflMetadata$Band_Window_2_Nanometers
# Plot spectral signatures again with rectangles showing the absorption bands
ggplot() +
geom_line(data = Pixel.melt, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
geom_rect(mapping = aes(ymin = min(Pixel.melt$Reflectance),
ymax = max(Pixel.melt$Reflectance),
xmin = ab1[1], xmax = ab1[2]),
color = "black", fill = "grey40", alpha = 0.8) +
geom_rect(mapping = aes(ymin = min(Pixel.melt$Reflectance),
ymax = max(Pixel.melt$Reflectance),
xmin = ab2[1], xmax = ab2[2]),
color = "black", fill = "grey40", alpha = 0.8) +
scale_colour_manual(values = c("green2", "green4", "green", "tan4", "blue3"),
labels = c("Forest1", "Forest2", "Forest3", "Anthropogenic", "Water")) +
labs(color = "Cover Type") +
ggtitle("Land cover spectral signatures") +
theme(plot.title = element_text(hjust = 0.5, size = 20)) +
xlab("Wavelength")
# Duplicate the spectral signatures into a new data.frame
Pixel.melt.masked <- Pixel.melt
# Mask out all values within each of the two atmospheric absorbtion bands
Pixel.melt.masked[Pixel.melt.masked$wavelengths >
ab1[1] & Pixel.melt.masked$wavelengths < ab1[2], ]$Reflectance <- NA
# Mask out all values within each of the two atmospheric absorbtion bands
Pixel.melt.masked[Pixel.melt.masked$WL >
ab1[1] & Pixel.melt.masked$WL < ab1[2], ]$Reflectance <- NA
Pixel.melt.masked[Pixel.melt.masked$WL >
ab2[1] & Pixel.melt.masked$WL < ab2[2], ]$Reflectance <- NA
# Plot the masked spectral signatures
ggplot() +
geom_line(data = Pixel.melt.masked, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
scale_colour_manual(values = c("green2", "green4", "grey50","tan4","blue3"),
labels = c("Field", "Tree", "Roof", "Soil", "Water"))+
labs(color = "Cover Type")+
ggtitle("Land cover spectral signatures")+
theme(plot.title = element_text(hjust = 0.5, size=20))+
xlab("Wavelength")
# Plot the masked spectral signatures
ggplot() +
geom_line(data = Pixel.melt.masked, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
scale_colour_manual(values = c("green2", "green4", "green","tan4","blue3"),
labels = c("Forest1", "Forest2", "Forest3", "Anthropogenic", "Water"))+
labs(color = "Cover Type")+
ggtitle("Land cover spectral signatures")+
theme(plot.title = element_text(hjust = 0.5, size=20))+
xlab("Wavelength")
# Plot the masked spectral signatures
ggplot() +
geom_line(data = Pixel.melt.masked, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
scale_colour_manual(values = c("green2", "green4", "olivegreen","tan4","blue3"),
labels = c("Forest1", "Forest2", "Forest3", "Anthropogenic", "Water"))+
labs(color = "Cover Type")+
ggtitle("Land cover spectral signatures")+
theme(plot.title = element_text(hjust = 0.5, size=20))+
xlab("Wavelength")
# Plot the masked spectral signatures
ggplot() +
geom_line(data = Pixel.melt.masked, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
scale_colour_manual(values = c("green2", "green4", "chartreuse3","tan4","blue3"),
labels = c("Forest1", "Forest2", "Forest3", "Anthropogenic", "Water"))+
labs(color = "Cover Type")+
ggtitle("Land cover spectral signatures")+
theme(plot.title = element_text(hjust = 0.5, size=20))+
xlab("Wavelength")
# Plot spectral signatures again with rectangles showing the absorption bands
ggplot() +
geom_line(data = Pixel.melt, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
geom_rect(mapping = aes(ymin = min(Pixel.melt$Reflectance),
ymax = max(Pixel.melt$Reflectance),
xmin = ab1[1], xmax = ab1[2]),
color = "black", fill = "grey40", alpha = 0.8) +
geom_rect(mapping = aes(ymin = min(Pixel.melt$Reflectance),
ymax = max(Pixel.melt$Reflectance),
xmin = ab2[1], xmax = ab2[2]),
color = "black", fill = "grey40", alpha = 0.8) +
scale_colour_manual(values = c("green2", "green4", "chartreuse3", "tan4", "blue3"),
labels = c("Forest1", "Forest2", "Forest3", "Anthropogenic", "Water")) +
labs(color = "Cover Type") +
ggtitle("Land cover spectral signatures") +
theme(plot.title = element_text(hjust = 0.5, size = 20)) +
xlab("Wavelength")
# Now, let's plot some spectral signatures!
ggplot() +
geom_line(data = Pixel.melt, mapping = aes(x = WL,
y = Reflectance,
color = variable), lwd = 1.5) +
scale_colour_manual(values = c("green2", "green4", "chartreuse3", "tan4", "blue3"),
labels = c("Forest1", "Forest2", "Forest3", "Anthropogenic", "Water"))+
labs(color = "Cover Type") +
ggtitle("Land cover spectral signatures") +
theme(plot.title = element_text(hjust = 0.5, size = 20)) +
xlab("Wavelength")
# It's always good practice to close the H5 connection before moving on!
# close the H5 file
H5close()
plot(ndvi_calc)
HARV_rao <- paRao(ndvi_calc, window = 3, dist_m = "euclidean")
HARV_shannon <- Shannon(ndvi_calc, window = 3)
HARV_shannon
plot(HARV_shannon)
HARV_shannon <- Shannon(ndvi_calc, window = 5)
plot(HARV_shannon)
