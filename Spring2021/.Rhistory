}
modelTimes = seq(from = tStart, to = tEnd, by = 0.1)#Note timestep here doesn't affect integration timestep, this is purely for the output
#Actually solve:
odeOut = ode(y = modelState, times = modelTimes, func = dModel, parms = modelParams)
#Package output back up into same structure as input
stateOut = list(time = odeOut[, "time"])
#Populations:
for(population in initialModelState$populations) {
for(cName in names(population$state)) {
globalClassName = paste0(population$name, cName)
stateOut[[population$name]][[cName]] = odeOut[, globalClassName]
}
}
#Inoculum
for(iName in names(initialModelState$inoculumPool$inoculum)) {
stateOut[["inoculum"]][[iName]] = odeOut[, iName]
}
return(stateOut)
}
fitModelParamsFromAnalytic = function(assumedDropletInfectionProportion = 0.5, assumedR0 = 2.5, populationSize = 6e7) {
#Note that all the tX parameters are actually _rates_, so need to use 1/tX wherever it appears in an analytic expression
if(assumedDropletInfectionProportion > 1.0 | assumedDropletInfectionProportion < 0.0) {
stop("assumedDropletInfectionProportion must be in range [0.0, 1.0]")
}
baselineEpiParams = createPopParameters()
baselineInoculumParams = createInoculumPool()$parameters
#This quantity appears in all the rate parameters
coreRatio = assumedR0 / (((baselineEpiParams$bC / baselineEpiParams$tC) + (baselineEpiParams$bI / baselineEpiParams$tI)) * populationSize)
params = list(
bD = coreRatio *        assumedDropletInfectionProportion  / (1.0 / baselineInoculumParams$tD),
bF = coreRatio * (1.0 - assumedDropletInfectionProportion) / (1.0 / baselineInoculumParams$tF)
)
return(params)
}
runScenario = function(modelParameters, maskParameters, quarantineParameters, initialExposed, populationSize, timespan) {
#Checking the mask wearing start time - don't want it to be longer than the simulation length, or things will go wonky
if(maskParameters$startTime > timespan) {
stop(paste0("Specified start time for mask wearing (", maskParameters$startTime, ") was later than the end of the simulation (", timespan, ")"))
}
#Pre mask
modelPopulationsPreMask = list(createPopulation(name = "NoMask",
popState = list(S = populationSize, E = initialExposed),
pop_bD = modelParameters$bD, pop_bF = modelParameters$bF)
)
modelStatePreMask = list(populations = modelPopulationsPreMask,
inoculumPool = createInoculumPool())
if(maskParameters$startTime > 0.0) {
modelResultsPreMask = runModel(initialModelState = modelStatePreMask,
timeSpan = maskParameters$startTime,
pandemicManagement = quarantineParameters)
} else {
modelResultsPreMask = list(time = 0.0,
NoMask = modelPopulationsPreMask[[1]]$state,
inoculum = modelStatePreMask$inoculumPool$inoculum)
}
iFinalTime = length(modelResultsPreMask$time)
#Allocate people randomly as mask and non-mask wearers
#TODO: Could have people preferentially wearing masks if they have symptoms,
#but this is unlikely to make a difference as the effect is very transient due to only affecting individuals at the time masks are first adopted
popNoMask = list()
popMask = list()
for(cName in names(modelResultsPreMask$NoMask)) {
classFinalValue = modelResultsPreMask$NoMask[[cName]][iFinalTime]
popNoMask[[cName]] = (1.0 - maskParameters$proportion) * classFinalValue
popMask[[cName]] = maskParameters$proportion * classFinalValue
}
#Post mask
modelPopulationsPostMask = list(createPopulation(name = "NoMask",
popState = popNoMask,
pop_bD = modelParameters$bD, pop_bF = modelParameters$bF),
createPopulation(name = "Mask",
popState = popMask,
pop_bD = modelParameters$bD, pop_bF = modelParameters$bF,
pop_mI = 1.0 - maskParameters$exhaleCapture, pop_mD = 1.0 - maskParameters$inhaleCapture, pop_mF = 1.0 - maskParameters$fomiteCapture)
)
modelInoculumPoolPostMask = createInoculumPool()
for(iName in names(modelResultsPreMask$inoculum)) {
modelInoculumPoolPostMask$inoculum[[iName]] = modelResultsPreMask$inoculum[[iName]][iFinalTime]
}
modelStatePostMask = list(populations = modelPopulationsPostMask,
inoculumPool = modelInoculumPoolPostMask)
modelResultsPostMask = runModel(initialModelState = modelStatePostMask,
timeSpan = c(maskParameters$startTime, timespan),
pandemicManagement = quarantineParameters)
modelTime = c(modelResultsPreMask$time, modelResultsPostMask$time)
noMaskResults = list()
maskResults = list()
for(cName in names(modelResultsPreMask$NoMask)) {
noMaskResults[[cName]] = c(      modelResultsPreMask$NoMask[[cName]], modelResultsPostMask$NoMask[[cName]])
maskResults[[cName]]   = c(0.0 * modelResultsPreMask$NoMask[[cName]], modelResultsPostMask$Mask[[cName]])#Mask wearer stats are zero before they exist
}
inoculumResults = list(D=c(modelResultsPreMask$inoculum$D, modelResultsPostMask$inoculum$D),
F=c(modelResultsPreMask$inoculum$F, modelResultsPostMask$inoculum$F))
runResults = list(time = modelTime,
noMaskResults = noMaskResults,
maskResults = maskResults,
inoculumResults = inoculumResults)
scenarioData = list(runResults = runResults,
maskParameters = maskParameters,
quarantineParameters = quarantineParameters,
initialExposed = initialExposed,
populationSize = populationSize)
}
getMaskString = function(maskParams, omitProportion=FALSE) {
maskString = "No Masks"
if(maskParams$proportion > 0.0 | omitProportion == TRUE) {#omitProportion probably wants us to ignore No Masks output?
maskString = paste0("Masks: ")
if(maskParams$startTime > 0) {
maskString = paste0(maskString, "Start: T+", maskParams$startTime, " days, ")
}
if(omitProportion != TRUE) {
maskString = paste0(maskString, sprintf("%.0f%%", 100.0 * maskParams$proportion), " wearing, ")
}
maskString = paste0(maskString, "inoculum capture: ", sprintf("%.0f%%", 100.0 * maskParams$exhaleCapture), " exhale, ", sprintf("%.0f%%", 100.0 * maskParams$inhaleCapture), " inhale, fomite ", sprintf("%.0f%%", 100.0 * maskParams$fomiteCapture))
}
return(maskString)
}
getQuarantineString = function(quarantineParams) {
quarantineString = "No Lock-down"
if(quarantineParams$nQuarantineCycles > 0) {
quarantineString = paste0("Lock-down: Start: T+", quarantineParams$tFirstQuarantine, " days, duration: ", quarantineParams$durationQuarantineCycle, " days, ", sprintf("%.0f%%", 100.0 * quarantineParams$quarantineReductionInGoingOut), " contact reduction, ", quarantineParams$durationBetweenQuarantineCycles, " days off, ", quarantineParams$nQuarantineCycles, " cycles")
}
return(quarantineString)
}
plotLine = function(x, y, col, lty, lwd, legendString) {
lines(x = x, y = y, col = col, lty = lty, lwd = lwd)
legendData = list(string = legendString,
col = col,
lty = lty,
lwd = lwd)
return(legendData)
}
plotScenario = function(scenarioData) {
maskString = getMaskString(scenarioData$maskParameters)
quarantineString = getQuarantineString(scenarioData$quarantineParameters)
#Show y axis as cases per million, not absolute nummbers
caseScaling = 1e-6
totalResults = list()
for(cName in names(scenarioData$runResults$noMaskResults)) {
scenarioData$runResults$noMaskResults[[cName]] = scenarioData$runResults$noMaskResults[[cName]] * caseScaling
scenarioData$runResults$maskResults[[cName]]   = scenarioData$runResults$maskResults[[cName]]   * caseScaling
totalResults[[cName]] = scenarioData$runResults$noMaskResults[[cName]] + scenarioData$runResults$maskResults[[cName]]
}
yMax = scenarioData$populationSize * caseScaling
while(yMax > 20.0*max(totalResults$R)) {
yMax = yMax / 10.0
}
#Probably would have been better to use ggplot
plot(type = "n",
x = -1,
xlim = range(scenarioData$runResults$time),
ylim = c(0, yMax),
xlab = paste0("Time since outbreak first reached ", scenarioData$initialExposed, " infected individuals (days)"),
ylab = "Cases (millions)",
main = paste0(maskString, "\n", quarantineString),
cex.main = 2, cex.lab = 1.9, cex.axis = 2)#TODO: Larger axis labels
legendData = plotLine(x = scenarioData$runResults$time, y = totalResults$R, col = "black", lty = 1, lwd = 2, legendString = "Total Removed")
ld = plotLine(x = scenarioData$runResults$time, y = totalResults$I, col = "red", lty = 1, lwd = 2, legendString = "Total active symptomatic")
for(lName in names(legendData)) {legendData[[lName]] = c(legendData[[lName]], ld[[lName]])}
if(scenarioData$maskParameters$proportion > 0.0 & scenarioData$maskParameters$proportion < 1.0) {
ld = plotLine(x = scenarioData$runResults$time, y = scenarioData$runResults$maskResults$R, col = "grey", lty = 2, lwd = 2, legendString = "Mask wearers removed")
for(lName in names(legendData)) {legendData[[lName]] = c(legendData[[lName]], ld[[lName]])}
ld = plotLine(x = scenarioData$runResults$time, y = scenarioData$runResults$noMaskResults$R, col = "black", lty = 3, lwd = 2, legendString = "Non-mask wearers removed")
for(lName in names(legendData)) {legendData[[lName]] = c(legendData[[lName]], ld[[lName]])}
}
#Inoculum:
#scaledInoc = scenarioData$runResults$inoculumResults$F * yMax / max(scenarioData$runResults$inoculumResults$F)
#ld = plotLine(x = scenarioData$runResults$time, y = scaledInoc, col = "blue", lty = 1, lwd = 2, legendString = "Scaled fomite inoculum")
#for(lName in names(legendData)) {legendData[[lName]] = c(legendData[[lName]], ld[[lName]])}
plotQuarantinePeriods(pandemicManagementParams = scenarioData$quarantineParameters)
#Date mask start usage:
if(scenarioData$maskParameters$proportion > 0.0) {
abline(v = scenarioData$maskParameters$startTime, col = "blue", lty = 3, lwd = 3)
}
legend("topleft",
legend = legendData$string,
col = legendData$col,
lty = legendData$lty,
lwd = legendData$lwd,
cex = 2)
}
#Simulation settings:
individualPlotSize = c(1920*0.5, 1080*0.5)
popSize = 6e7
fittedModelParameters = fitModelParamsFromAnalytic(assumedR0 = 4.0, assumedDropletInfectionProportion = 0.5, populationSize = popSize)
modelTimespan = 540
modelInitialExposed = 100
#Baseline parameters:
maskEffectivenessParameters = list(exhaleCapture = 0.5, inhaleCapture = 0.5, fomiteCapture = 0.0)
noMasks = list(
exhaleCapture = 0.0,
inhaleCapture = 0.0,
fomiteCapture = 0.0,
startTime = 0.0,
proportion = 0.0)
quarantineParameters = createPandemicManagementParameters(tFirstQuarantine = 45,
durationQuarantineCycle = 90,
durationBetweenQuarantineCycles = 30,
nQuarantineCycles = 4,
quarantineReductionInGoingOut = 0.5)
#Panel: quarantine + various levels of mask wearing
masks = list(noMasks)
maskProportions = c(0.25, 0.50, 1.00)
for(maskProportion in maskProportions) {
maskParams = list(
exhaleCapture = maskEffectivenessParameters$exhaleCapture,
inhaleCapture = maskEffectivenessParameters$inhaleCapture,
fomiteCapture = maskEffectivenessParameters$fomiteCapture,
startTime = 0.0,
proportion = maskProportion)
masks[[length(masks)+1]] = maskParams
}
quarantines = list()
qStarts = c(45, 45, 45, 45)
for(qStart in qStarts) {
qParams = quarantineParameters
qParams$tFirstQuarantine = qStart
quarantines[[length(quarantines)+1]] = qParams
}
mqs = list()#TODO: function called zip does this?
for(iMask in seq_len(length(masks))){
mqs[[length(mqs)+1]] = list(m = masks[[iMask]], q = quarantines[[iMask]])
}
nRows = 2
nCols = ceiling(length(mqs) / nRows)
png(filename = "Paper_5_MaskProportionPanel.png", width = individualPlotSize[1]*nCols, height = individualPlotSize[2]*nRows)
oPar = par(mfrow = c(nRows, nCols),
oma = c(5,4,0,0) + 0.1,
mar = c(4,5,4,1) + 0.1)
iFig = 1
for(mq in mqs) {
scenarioResults = runScenario(modelParameters = fittedModelParameters,
maskParameters = mq$m,
quarantineParameters = mq$q,
initialExposed = modelInitialExposed,
populationSize = popSize,
timespan = modelTimespan)
plotScenario(scenarioData = scenarioResults)
#Label
fb = par("usr")
text(labels = paste0("(", letters[iFig], ")"), x = fb[1] + 0.95 * (fb[2] - fb[1]), y = fb[3] + 0.9 * (fb[4] - fb[3]), cex = 5)
iFig = iFig + 1
}
#Restore old par settings
par(oPar)
dev.off()
#Panel: quarantine + timing of mask wearing before first Q, around peak of I, at end of first Q
masks = list()
maskStartTimes = c(30, 60, 90, 120)
for(maskStartTime in maskStartTimes) {
maskParams = list(
exhaleCapture = maskEffectivenessParameters$exhaleCapture,
inhaleCapture = maskEffectivenessParameters$inhaleCapture,
fomiteCapture = maskEffectivenessParameters$fomiteCapture,
startTime = maskStartTime,
proportion = 1.0)
masks[[length(masks)+1]] = maskParams
}
nRows = 2
nCols = ceiling(length(masks) / nRows)
oPar = par(mfrow = c(nRows, nCols),
oma = c(5,4,0,0) + 0.1,
mar = c(4,5,4,1) + 0.1)
iFig = 1
for(mask in masks) {
scenarioResults = runScenario(modelParameters = fittedModelParameters,
maskParameters = mask,
quarantineParameters = quarantineParameters,
initialExposed = modelInitialExposed,
populationSize = popSize,
timespan = modelTimespan)
plotScenario(scenarioData = scenarioResults)
#Label
fb = par("usr")
text(labels = paste0("(", letters[iFig], ")"), x = fb[1] + 0.95 * (fb[2] - fb[1]), y = fb[3] + 0.9 * (fb[4] - fb[3]), cex = 5)
iFig = iFig + 1
}
#Restore old par settings
par(oPar)
dev.off()
require(maptools)
require(rgdal)
require(raster)
require(sp)
require(rangeBuilder)
library(spdep)
library(ncf)
require(geiger)
require(dismo)
library(letsR)
library(rworldmap)
require(spatialreg)
require(picante)
require(ape)
oaks <- read.table("Data/OCC/live.oaks.txt", header = TRUE)
head(oaks)
tail(oaks)
unique(oaks$Species)
# Select the focal species
que_vir <- subset(oaks, oaks$Species == "Quercus_virginiana")
oaks_dups <- duplicated(oaks[, c(2:3)])
### NOTE: the function "duplicated" returns the results of a logical test
# (e.g. TRUE or FALSE)
# How many are duplicates?
length(which(oaks_dups == TRUE))
# How many are NOT duplicates?
length(which(oaks_dups == FALSE))
# Keep only those lines that are not duplicates
oaks_dups_row <- which(oaks_dups == TRUE)
# What's the size? That is, how many points are duplicates
length(oaks_dups_row)
# Create another object without the duplicate records
oaks_nodups <- oaks[-oaks_dups_row,]
# What are the dimensions of the new object?
dim(oaks_nodups)
# Take a look at the first rows of data
head(oaks_nodups)
?convHull
# create a polygon around the species' records
oaks_hull <- convHull(oaks_nodups[, c(2:3)])
str(oaks_hull)
# Plot the created polygon
plot(oaks_hull)
points(oaks_nodups$Longitude, oaks_nodups$Latitude, pch = 16, col = "black")
# create a polygon around the species' records
oaks_hull <- convHull(oaks_nodups[, c(3:2)])
str(oaks_hull)
# Plot the created polygon
plot(oaks_hull)
points(oaks_nodups$Longitude, oaks_nodups$Latitude, pch = 16, col = "black")
# create a polygon around the species' records
oaks_hull <- convHull(oaks_nodups[, c(2:3)])
#str(oaks_hull)
# Plot the created polygon
plot(oaks_hull)
points(oaks_nodups$Longitude, oaks_nodups$Latitude, pch = 16, col = "black")
que_vir_hull <- dismo::convHull(que_vir[, c(2:3)])
plot(que_vir_hull)
points(que_vir$Longitude, que_vir$Latitude, pch = 16, col = "black")
que_vir_alphahull <- getDynamicAlphaHull(que_vir, fraction = 0.95,
coordHeaders = c("Longitude", "Latitude"),
clipToCoast = 'no')[[1]]
plot(que_vir_alphahull, lwd = 2, col = "red")
plot(que_vir_hull, add = TRUE, lwd = 2, lty = 2)
points(que_vir$Longitude, que_vir$Latitude, pch = 16, col = "green")
plot(countriesCoarse, add = TRUE, lwd = 2)
?getDynamicAlphaHull
que_vir_alphahull <- getDynamicAlphaHull(que_vir, fraction = 0.95,
coordHeaders = c("Longitude", "Latitude"),
clipToCoast = 'no')[[1]]
plot(que_vir_alphahull, lwd = 2, col = "red")
#plot(que_vir_hull, add = TRUE, lwd = 2, lty = 2)
points(que_vir$Longitude, que_vir$Latitude, pch = 16, col = "green")
plot(countriesCoarse, add = TRUE, lwd = 2)
franges <- readOGR(dsn = "Data/Franges", layer = "Furnarii_ranges_geo")
str(franges)
class(franges)
fur_ruf <- subset(franges, franges$SCINAME == "Furnarius rufus")
ana_dor <- subset(franges, franges$SCINAME == "Anabazenops dorsalis")
SA <- subset(countriesCoarse, continent == "South America")
plot(SA)
plot(fur_ruf, col = "green", add = TRUE) # Furnarius rufus
plot(ana_dor, add = TRUE, col = "red") # Anabazenops dorsalis
# Add world maps
plot(SA, add = TRUE)
neo_ras <- raster()
extent(neo_ras) <- extent(franges) # Set the raster "extent"
res(neo_ras) <- 1 # Set the raster "resolution"
neo_ras
values(neo_ras) <- 0
f_sr_raster <- rasterize(franges, neo_ras, field = "SCINAME",
fun = function(x,...){length(unique(na.omit(x)))})
plot(f_sr_raster)
plot(SA, add = TRUE)
plot(f_sr_raster, col = rev(colfuncYellows(100)), axes = FALSE, box = FALSE,
zlim = c(minValue(f_sr_raster), maxValue(f_sr_raster)),
xlab = "Furnariides richness", legend.width = 2)
#change the color scale
colfuncYellows <- colorRampPalette(c("#d7191c", "#fdae61", "#ffffbf",
"#abd9e9", "#2c7bb6"))
plot(f_sr_raster, col = rev(colfuncYellows(100)), axes = FALSE, box = FALSE,
zlim = c(minValue(f_sr_raster), maxValue(f_sr_raster)),
xlab = "Furnariides richness", legend.width = 2)
plot(SA, add = TRUE)
head(franges@data)
f_MRD_raster <- rasterize(franges, neo_ras, field = "RD", fun = mean)
plot(f_MRD_raster)
plot(SA, add = TRUE)
plot(f_MRD_raster, col = rev(colfuncYellows(100)), axes = FALSE, box = FALSE,
zlim = c(minValue(f_MRD_raster), maxValue(f_MRD_raster)),
xlab = "Furnariides mean root distance", legend.width = 2)
plot(SA, add = TRUE)
par(mfrow = c(1, 2))
plot(f_sr_raster, col = rev(colfuncYellows(100)), axes = FALSE, box = FALSE,
zlim = c(minValue(f_sr_raster), maxValue(f_sr_raster)),
xlab = "Furnariides richness", legend.width = 2)
plot(f_MRD_raster, col = rev(colfuncYellows(100)), axes = FALSE, box = FALSE,
zlim = c(minValue(f_MRD_raster), maxValue(f_MRD_raster)),
xlab = "Furnariides mean root distance", legend.width = 2)
cor.test(values(f_sr_raster), values(f_MRD_raster))
obj <- lm(values(f_sr_raster) ~ values(f_MRD_raster))
summary(obj)
plot(values(f_sr_raster) ~ values(f_MRD_raster), xlab = "MRD", ylab = "SR")
abline(obj, col = "red", lwd = 2)
f_MRD_raster <- rasterize(franges, neo_ras, field = "RD", fun = mean)
plot(f_MRD_raster)
plot(SA, add = TRUE)
plot(f_MRD_raster, col = rev(colfuncYellows(100)), axes = FALSE, box = FALSE,
zlim = c(minValue(f_MRD_raster), maxValue(f_MRD_raster)),
xlab = "Furnariides mean root distance", legend.width = 2)
plot(SA, add = TRUE)
par(mfrow = c(1, 2))
plot(f_sr_raster, col = rev(colfuncYellows(100)), axes = FALSE, box = FALSE,
zlim = c(minValue(f_sr_raster), maxValue(f_sr_raster)),
xlab = "Furnariides richness", legend.width = 2)
plot(f_MRD_raster, col = rev(colfuncYellows(100)), axes = FALSE, box = FALSE,
zlim = c(minValue(f_MRD_raster), maxValue(f_MRD_raster)),
xlab = "Furnariides mean root distance", legend.width = 2)
bio1 <- raster("Data/Envi/bio1.bil")
bio1
bio12 <- raster("Data/Envi/bio12.bil")
bio12
par(mfrow = c(2, 1))
plot(bio1)
plot(bio12)
bio1_neo <- crop(bio1, extent(franges))
bio12_neo <- crop(bio12, extent(franges))
par(mfrow = c(1, 2))
plot(bio1_neo, main = "Annual Mean Temperature")
plot(bio12_neo, main = "Annual Precipitation")
f_ras_bios <- extract(stack(bio1_neo, bio12_neo), f_ras_coords)
f_ras_coords <- xyFromCell(f_sr_raster, 1:length(values(f_sr_raster)))
head(f_ras_coords)
f_ras_bios <- extract(stack(bio1_neo, bio12_neo), f_ras_coords)
fdata <- na.omit(data.frame(f_ras_coords, SR = values(f_sr_raster),
MRD = values(f_MRD_raster), f_ras_bios))
head(fdata)
cor.test(fdata$SR, fdata$bio1)
cor.test(fdata$SR, fdata$bio12)
par(mfrow = c(1, 2))
plot(fdata$bio1, fdata$SR, xlab = "Bio 1", ylab = "Richness")
plot(fdata$bio12, fdata$SR, xlab = "Bio 12", ylab = "Richness")
obj2 <- lm(SR ~ bio1 + bio12, data = fdata)
summary(obj2)
lmbio1 <- lm(SR ~ bio1, data = fdata)
summary(lmbio1)
lmbio12 <- lm(SR ~ bio12, data = fdata)
summary(lmbio12)
fols <- lm(SR ~ bio1 + bio12, data = fdata)
summary(fols)
fols2 <- lm(SR ~ bio1 + bio12 + MRD, data = fdata)
summary(fols2)
autocor_SR <- ncf::correlog(fdata$x, fdata$y, z = fdata$SR, na.rm = T,
increment = 1, resamp = 1)
plot(autocor_SR$correlation[1:50], type = "b", pch = 1, cex = 1.2, lwd = 1.5,
ylim = c(-1, 1), xlab = "Distance class", ylab = "Moran's I", cex.lab = 1.2,
cex.axis = 1.2)
abline(h = 0)
autocor_SR
summary(autocor_SR)
autocor_SR <- ncf::correlog(fdata$x, fdata$y, z = fdata$SR, na.rm = T,
increment = 1, resamp = 1)
coords <- fdata[1:2]
coords <- as.matrix(coords)
nb1.5 <- dnearneigh(coords, 0, 1.5)
nb1.5.w <- nb2listw(nb1.5, glist = NULL, style = "W", zero.policy = TRUE)
residuals_ols <- residuals(fols2)
plot(residuals_ols)
autocor_ols_res <- correlog(fdata$x, fdata$y, z = residuals(fols),
increment = 1, resamp = 1)
plot(autocor_ols_res$correlation[1:50], type = "b", pch = 1, cex = 1.2, lwd = 1.5,
ylim = c(-0.5, 1), xlab = "distance", ylab = "Moran's I", cex.lab = 1.5,
cex.axis = 1.2)
abline(h = 0)
title(main = "OLS residuals", cex = 1.5)
par(mfrow = c(2, 1))
plot(autocor_SR$correlation[1:50], type = "b", pch = 1, cex = 1.2, lwd = 1.5,
ylim = c(-1, 1), xlab = "Distance class", ylab = "Moran's I", cex.lab = 1.2,
cex.axis = 1.2)
abline(h = 0)
title(main = "OLS model", cex = 1.5)
plot(autocor_ols_res$correlation[1:50], type = "b", pch = 1, cex = 1.2, lwd = 1.5,
ylim = c(-0.5, 1), xlab = "Distance class", ylab = "Moran's I", cex.lab = 1.5,
cex.axis = 1.2)
abline(h = 0)
title(main = "OLS residuals", cex = 1.5)
sar_nb1.5.w <- errorsarlm(fols2, listw = nb1.5.w, data = fdata, quiet = FALSE,
zero.policy = TRUE, na.action = na.exclude)
summary(sar_nb1.5.w)
residuals_sar_nb1.5.w <- residuals(sar_nb1.5.w)
summary(sar_nb1.5.w)
residuals_sar_nb1.5.w <- residuals(sar_nb1.5.w)
autocor_sar_nb1.5.w <- correlog(fdata$x, fdata$y, z = residuals(sar_nb1.5.w),
na.rm = T, increment = 1, resamp = 1)
plot(autocor_sar_nb1.5.w$correlation[1:50], type = "b", pch = 4, cex = 1.2, lwd = 1.5,
ylim = c(-0.5, 1), xlab = "distance", ylab = "Moran's I", cex.lab = 1.5,
cex.axis = 1.2)
abline(h = 0)
title(main = "Correlogram SARerr", cex = 1.5)
par(mfrow = c(2, 1))
plot(autocor_ols_res$correlation[1:50], type = "b", pch = 1, cex = 1.2, lwd = 1.5,
ylim = c(-0.5, 1), xlab = "distance", ylab = "Moran's I", cex.lab = 1.5,
cex.axis = 1.2)
abline(h = 0)
title(main = "OLS residuals", cex = 1.5)
plot(autocor_sar_nb1.5.w$correlation[1:50], type = "b", pch = 4, cex = 1.2, lwd = 1.5,
ylim = c(-0.5, 1), xlab = "distance", ylab = "Moran's I", cex.lab = 1.5,
cex.axis = 1.2)
abline(h = 0)
title(main = "Correlogram SARerr", cex = 1.5)
summary(sar_nb1.5.w)
summary(fols2)
