quealb_thinned_spt <- SpatialPointsDataFrame(coords = quealb_thinned[, 1:2],
data = thinning,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
# The below code is using R base
quealb_thinned_spt <- SpatialPointsDataFrame(coords = quealb_thinned[, 1:2],
data = quealb_thinned,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
biosNames <- list.files("Data/Envi/wc10/", pattern = "bil$")
stack(paste0("Data/Envi/wc10/", biosNames))
plot(bios_NA[[1]]) # mean annual temperature
plot(quealb_thinned_spt, col = "red", pch = 16, add = TRUE) # add occurrence records
plot(bios_NA[[1]]) # mean annual temperature
plot(quealb_thinned_spt, col = "red", pch = 16, add = TRUE)
# check how the data are organized:
names(gbif_data)
gbif_data <- occ_data(scientificName = spp, hasCoordinate = TRUE, limit = 2000)
# check how the data are organized:
names(gbif_data)
names(gbif_data[[2]]$meta)
names(gbif_data[[2]]$data)
# get the columns that matter for mapping and cleaning the occurrence data:
occ_quealb <- gbif_data[[2]]$data[, c("decimalLongitude", "decimalLatitude",
"scientificName", "occurrenceStatus",
"coordinateUncertaintyInMeters",
"institutionCode", "references")]
head(occ_quealb)
# get the columns that matter for mapping and cleaning the occurrence data:
occ_quemin <- gbif_data[[2]]$data[, c("decimalLongitude", "decimalLatitude",
"scientificName", "occurrenceStatus",
"coordinateUncertaintyInMeters",
"institutionCode", "references")]
head(occ_quemin)
View(occ_quemin)
occ_quemin <- occ_quemin %>%
filter(!is.na(decimalLongitude & !is.na(decimalLatitude)))
occ_quemin <- coord_incomplete(coord_imprecise(coord_impossible(coord_unlikely(occ_quemin))))
glimpse(occ_quemin)
quemin_spt <- st_as_sf(occ_quemin,
coords = c("decimalLongitude", "decimalLatitude"),
crs = 4326) %>%
st_cast("MULTIPOINT")
glimpse(quemin_spt)
# world map
worldMap <- rnaturalearth::ne_countries(scale = "medium",
type = "countries",
returnclass = "sf")
sf_use_s2(FALSE)
# world map
worldMap <- rnaturalearth::ne_countries(scale = "medium",
type = "countries",
returnclass = "sf")
# country subset
USpoly <- worldMap %>%
#filter(region_wb == "North America")
filter(admin == "United States of America")
ggplot() +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "darkgray", alpha = 0.5) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
quemin_thinned <- thin(
loc.data =  occ_quemin,
verbose = FALSE,
long.col = "decimalLongitude",
lat.col = "decimalLatitude",
spec.col = "scientificName",
thin.par = 5, # points have at least a minimum distance of 5 km from each other
reps = 1,
locs.thinned.list.return = TRUE,
write.files = FALSE,
out.dir = "Data/OCC/")
quemin_thinned <- as.data.frame(quemin_thinned)
quemin_thinned$Species <- "Quercus_minima"
glimpse(quemin_thinned)
quemin_thinned_sf <- st_as_sf(quemin_thinned,
coords = c("Longitude", "Latitude"),
crs = 4326) %>%
st_cast("MULTIPOINT")
# The below code is using R base. We will use this object for the modelling part
quemin_thinned_spt <- SpatialPointsDataFrame(coords = quemin_thinned[, 1:2],
data = quemin_thinned,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
ggplot() +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "blue", alpha = 0.5) +
geom_sf(data = quemin_thinned_sf, color = "red", alpha = 0.3) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
#| eval: false
packages <- c("raster", "sp", "rgeos", "rworldmap", "dismo", "rgdal", "maptools",
"kernlab", "rgbif", "scrubr", "spThin", "sdmvspecies", "mmap", "sf")
# Package vector names
#| eval: false
# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages], dependencies = TRUE)
}
#| eval: false
if ( ! ("scrubr" %in% installed.packages())) {remotes::install_github("ropensci/scrubr")}
#| eval: false
sapply(packages, require, character.only = TRUE)
library(sdm)
library(scrubr)
library(tidyverse)
#| eval: false
spp <- c("Quercus virginiana", "Quercus minima", "Quercus alba", "Quercus fusiformis")
#| eval: false
gbif_data <- occ_data(scientificName = spp, hasCoordinate = TRUE, limit = 2000)
#decrease the 'limit' if you just want to see how many records there are without waiting all the time that it will take to download the whole dataset.
# Save the raw data
dir.create("Data")
dir.create("Data/OCC")
# save the donwloaded in the working directory
save(gbif_data, file = "Data/OCC/oaks_raw_occ.RDATA")
# check how the data are organized:
names(gbif_data)
names(gbif_data[[2]]$meta)
names(gbif_data[[2]]$data)
#| eval: false
# get the columns that matter for mapping and cleaning the occurrence data:
occ_quemin <- gbif_data[[2]]$data[, c("decimalLongitude", "decimalLatitude",
"scientificName", "occurrenceStatus",
"coordinateUncertaintyInMeters",
"institutionCode", "references")]
head(occ_quemin)
unique(occ_quemin$scientificName)
occ_quemin$scientificName
glimpse(occ_quemin)
# It look like the data include two species, let's clean the data first
occ_quemin <- occ_quemin %>%
filter(scientificName == "Quercus minima (Sarg.) Small")
occ_quemin <- occ_quemin %>%
filter(!is.na(decimalLongitude & !is.na(decimalLatitude)))
occ_quemin <- coord_incomplete(coord_imprecise(coord_impossible(coord_unlikely(occ_quemin))))
glimpse(occ_quemin)
quemin_spt <- st_as_sf(occ_quemin,
coords = c("decimalLongitude", "decimalLatitude"),
crs = 4326) %>%
st_cast("MULTIPOINT")
# explore the data
glimpse(quemin_spt)
sf_use_s2(FALSE)
# world map
worldMap <- rnaturalearth::ne_countries(scale = "medium",
type = "countries",
returnclass = "sf")
# country subset
USpoly <- worldMap %>%
#filter(region_wb == "North America")
filter(admin == "United States of America")
ggplot() +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "darkgray", alpha = 0.5) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
quemin_thinned <- thin(
loc.data =  occ_quemin,
verbose = FALSE,
long.col = "decimalLongitude",
lat.col = "decimalLatitude",
spec.col = "scientificName",
thin.par = 2, # points have at least a minimum distance of 2 km from each other
reps = 1,
locs.thinned.list.return = TRUE,
write.files = FALSE,
out.dir = "Data/OCC/")
quemin_thinned <- as.data.frame(quemin_thinned)
quemin_thinned$Species <- "Quercus_minima"
glimpse(quemin_thinned)
quemin_thinned_sf <- st_as_sf(quemin_thinned,
coords = c("Longitude", "Latitude"),
crs = 4326) %>%
st_cast("MULTIPOINT")
# The below code is using R base. We will use this object for the modelling part
quemin_thinned_spt <- SpatialPointsDataFrame(coords = quemin_thinned[, 1:2],
data = quemin_thinned,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
ggplot() +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "blue", alpha = 0.5) +
geom_sf(data = quemin_thinned_sf, color = "red", alpha = 0.3) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
save(occ_quemin, quemin_spt, quemin_thinned_sf, quemin_thinned,
file = "Data/OCC/quemin_OCC_processed.RData")
rm(gbif_data, occ_quemin, quemin_spt)
dir.create("Data/Envi")
bios <- raster::getData("worldclim", var = "bio", res = 10,
download = TRUE, path = "Data/Envi")
biosNames <- list.files("Data/Envi/wc10/", pattern = "bil$")
names(bios)
str(bios[[1]])
NApoly <- subset(countriesCoarse, continent == "North America") # used as extent
plot(NApoly)
bios_NA <- crop(bios, NApoly)
plot(bios_NA[[1]]) # mean annual temperature
plot(quealb_thinned_spt, col = "red", pch = 16, add = TRUE) # add occurrence records
plot(bios_NA[[1]])
plot(quealb_thinned_spt, col = "red", pch = 16, add = TRUE)
quealb_thinned_spt
plot(bios_NA[[1]]) # mean annual temperature
plot(quemin_thinned_spt, col = "red", pch = 16, add = TRUE) # add occurrence records
plot(countriesCoarse, lwd = 2, lty = 2, add = TRUE)
NApoly
view(NApoly@data)
NApoly_spt <- subset(countriesCoarse, ADMIN == "United States of America") # used as extent
rm(NApoly_spt)
rm(NApoly)
USpoly_spt <- subset(countriesCoarse, ADMIN == "United States of America") # used as extent
plot(USpoly_spt)
bios_NA <- crop(bios, NApoly)
bios_NA <- crop(bios, USpoly2)
bios_US <- crop(bios, USpoly_spt)
plot(bios_US[[1]]) # mean annual temperature
bios_US <- crop(bios, USpoly)
plot(bios_US[[1]]) # mean annual temperature
USpoly
bios_US <- crop(bios, USpoly_spt)
plot(bios_US[[1]]) # mean annual temperature
rm(bios_NA)
plot(bios_US[[1]]) # mean annual temperature
plot(quemin_thinned_spt, col = "red", pch = 16, add = TRUE)
### Species specific accessible area
bb <- bbox(quemin_thinned_spt) # bounding box
e <- extent(c(bb[1]-3, bb[3]+3, bb[2]-3, bb[4]+3)) # bounding box + 300 km
p <- as(e, 'SpatialPolygons') # transform to polygon
crs(p) <- crs(bios_US) # use the geographical reference of the bioclimatic variables
crs(NAs) <- crs(bios_US)
crs(USpoly_spt) <- crs(bios_US)
out <- gIntersection(USpoly_spt, p, byid = FALSE) # use NAs to eliminate areas on the sea
plot(bios_US[[1]])
plot(p, add = TRUE, lty = 2)
plot(bios_US[[1]])
plot(p, add = TRUE, lty = 2)
plot(out, add = TRUE, lwd = 2)
bios_spp <- raster::crop(bios_US, out)
bios_spp <- raster::mask(bios_spp, out)
plot(bios_spp[[1]])
plot(quemin_thinned_spt, add = TRUE, col = "red", pch = 16)
plot(USpoly_spt, add = TRUE, lty = 2)
# Generate the data
absence <- randomPoints(mask = bios_spp[[1]],
n = round(nrow(quemin_thinned)*2, 0), # number of pseudoabsences
p = quemin_thinned_spt, # presence object
ext = extent(bios_spp) # extent
)
View(absence)
quemin_thinned
presence <- data.frame(quemin_thinned) # presence data
absence <- data.frame(absence) # pseudoabsence data
names(absence) <- names(presence)
quemin_thinned
# Pseudoabsences
absence <- data.frame(absence) # pseudoabsence data
absence$Species <- "Quercus_minima"
names(absence) <- names(presence)
presence$Occurrence <- 1 # presence data
absence$Occurrence <- 0 # pseudoabsence data
quemin <- rbind(presence, absence) # combine both information
quemin
coordinates(quemin) <- ~ Longitude + Latitude
crs(quemin) <- crs(bios_spp)
quemin
plot(bios_spp[[1]])
plot(quemin[quemin$Occurrence == 1, ], col = "blue", add = TRUE, pch = 16)
points(quemin[quemin$Occurrence == 0, ], col = "red", pch = 16)
save(presence, absence, quemin, file = "Data/OCC/quemin_PresAbs.RData")
save(bb, e, USpoly_spt, out, p, file = "Data/Envi/accessible_area_quemin.RData")
rm(absence, presence, bios, e, out, p, bb)
quemin_bios <- data.frame(raster::extract(bios_spp, quemin))
quemin_bios <- cbind(data.frame(quemin), quemin_bios)
quealb_bios <- quemin_bios[complete.cases(quemin_bios), ]
View(quealb_bios)
rm)quealb_bios
rm(quealb_bios)
quemin_bios <- quemin_bios[complete.cases(quemin_bios), ]
quemin_bios <- na.omit(quemin_bios)
head(quemin_bios)
glimpse(quemin_bios)
cor_mat <- cor(quemin_bios[, c(6:24)], method = 'spearman')
corrplot.mixed(cor_mat, tl.pos = "lt", tl.cex = 0.5, number.cex = 0.5,
addCoefasPercent = TRUE, mar = c(0, 0, 1, 0))
corrplot::corrplot.mixed(cor_mat,
tl.pos = "lt",
tl.cex = 0.5,
number.cex = 0.5,
addCoefasPercent = TRUE,
mar = c(0, 0, 1, 0))
# Install the package from source
remotes::install_git("https://gitup.uni-potsdam.de/macroecology/mecofun.git")
covar_sel <- mecofun::select07(X = quealb_bios[, -c(1:5)], # only predictors data
y = quealb_bios$Occurrence, # presence-absence data
threshold = 0.7) # here you can change the threshold for one
covar_sel <- mecofun::select07(X = quemin_bios[, -c(1:5)], # only predictors data
y = quemin_bios$Occurrence, # presence-absence data
threshold = 0.7) # here you can change the threshold for one
# Check out the structure of the resulting object:
str(covar_sel)
covar_sel$AIC
covar_sel$cor_mat
covar_sel$pred_sel
preds <- covar_sel$pred_sel
preds
#source("R-Functions/select07_mod.R")
source("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2021/R-Functions/select07_mod.R")
select07_v2(X = quemin_bios[, -c(1:5)], # only predictors data
y = quemin_bios$Occurrence, # presence-absence data
threshold = 0.7)
View(select07_v2)
preds
order(preds)
sort(preds)
bios_spp[preds]
bios_spp[[preds]]
bios_quemin_sel <- bios_spp[[preds]]
plot(bios_quemin_sel)
quemin
quealbDATA <- sdmData(formula = Occurrence ~ bio2 + bio5 + bio8 + bio9 + bio10 + bio12 + bio14 + bio18,
train = quemin, # presence-pseudoabsence data
predictors = bios_quemin_sel, # selected covariables
crs = crs(bios_quemin_sel))
quealbDATA
getmethodNames('sdm')
rm(quealbDATA)
quemin_DATA <- sdmData(formula = Occurrence ~ bio2 + bio5 + bio8 + bio9 + bio10 + bio12 + bio14 + bio18,
train = quemin, # presence-pseudoabsence data
predictors = bios_quemin_sel, # selected covariables
crs = crs(bios_quemin_sel))
quemin_DATA
getmethodNames('sdm')
quemin_DATA <- sdm(Occurrence~., # the presence-absence
data = queminDATA, # formula and data
methods = c("bioclim", "domain.dismo", "glm", "gam", "rf", "svm"), # algorithms
replication = "sub", test.percent = 30, n = 2, # training-testing subsampling
parallelSettings = list(ncore = 2, method = "parallel")) # parallel computation
quemin_DATA <- sdm(Occurrence~., # the presence-absence
data = quemin_DATA, # formula and data
methods = c("bioclim", "domain.dismo", "glm", "gam", "rf", "svm"), # algorithms
replication = "sub", test.percent = 30, n = 2, # training-testing subsampling
parallelSettings = list(ncore = 2, method = "parallel")) # parallel computation
quemin_DATA <- sdmData(formula = Occurrence ~ bio2 + bio5 + bio8 + bio9 + bio10 + bio12 + bio14 + bio18,
train = quemin, # presence-pseudoabsence data
predictors = bios_quemin_sel, # selected covariables
crs = crs(bios_quemin_sel))
quemin_DATA
quemin_SDM <- sdm(Occurrence~., # the presence-absence
data = quemin_DATA, # formula and data
methods = c("bioclim", "domain.dismo", "glm", "gam", "rf", "svm"), # algorithms
replication = "sub", test.percent = 30, n = 2, # training-testing subsampling
parallelSettings = list(ncore = 2, method = "parallel")) # parallel computation
quemin_SDM
roc(quemin_SDM, smooth = TRUE)
quemin_ENM_bioclim <- predict(quemin_SDM,
newdata = bios_quemin_sel,
method = "bioclim",
mean = TRUE)
quemin_ENM_bioclim
quemin_ENM_bioclim <- sdmvspecies::rescale(quemin_ENM_bioclim$sp_1.m_bioclim.re_subs)
plot(quemin_ENM_bioclim)
quemin_ENM_domain <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "domain.dismo", mean = TRUE)
quemin_ENM_glm <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "glm", mean = TRUE)
quemin_ENM_gam <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "gam", mean = TRUE)
quemin_ENM_rf <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "rf", mean = TRUE)
quemin_ENM_svm <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "svm", mean = TRUE)
quemin_ENM_domain <- sdmvspecies::rescale(quemin_ENM_domain$sp_1.m_domain.dismo.re_subs)
quemin_ENM_glm <- sdmvspecies::rescale(quemin_ENM_glm$sp_1.m_glm.re_subs)
quemin_ENM_gam <- sdmvspecies::rescale(quemin_ENM_gam$sp_1.m_gam.re_subs)
quemin_ENM_rf <- sdmvspecies::rescale(quemin_ENM_rf$sp_1.m_rf.re_subs)
quemin_ENM_svm <- sdmvspecies::rescale(quemin_ENM_svm$sp_1.m_svm.re_subs)
quemin_ENM_all <- raster::stack(quemin_ENM_bioclim, quemin_ENM_domain,
quemin_ENM_glm, quemin_ENM_gam,
quemin_ENM_svm, quemin_ENM_rf)
names(quemin_ENM_all) <- c("Bioclim", "Domain", "GLM", "GAM", "SVM", "RF")
plot(quealb_ENM_all)
plot(quemin_ENM_all)
### Ensemble prediction - ensemble based on TSS statistics
quemin_ENM_ensemble <- ensemble(quemin_SDM, # sdm object
newdata = bios_quemin_sel, # covariables
method = c("rf", "gam", "svm", "glm"),# algorithms
setting = list(method = "weighted", stat = "TSS"), # metric
parallelSettings = list(ncore = 2, method = "parallel"))
quemin_ENM_ensemble <- sdmvspecies::rescale(quemin_ENM_ensemble)
plot(quemin_ENM_ensemble)
dir.create("Results")
dir.create("Results/ENMs")
writeRaster(quemin_ENM_all, filename = "Results/ENMs/quemin_ENM",
suffix = names(quemin_ENM_all), format = "GTiff",
bylayer = TRUE, overwrite = TRUE)
# save the ensemble prediction
writeRaster(quemin_ENM_ensemble,
filename = "Results/ENMs/quemin_ENM_Ensemble",
format = "GTiff",
bylayer = TRUE,
overwrite = TRUE)
dt <- data.frame(as.data.frame(quemin_DATA), coordinates(quemin_DATA))
head(dt)
prediction <- raster::extract(quemin_ENM_ensemble, dt[, c("Longitude", "Latitude")])
evaluation <- sdm::evaluates(dt$Occurrence, prediction) # observed versus expected
threshold_sel <- evaluation@threshold_based$threshold[2]
round(threshold_sel, 2)
# reclassify our ensemble prediction
queminSDM_ensemble[] <- ifelse(quemin_SDM_ensemble[] >= threshold_sel, 1, 0)
quemin_SDM_ensemble <- quemin_ENM_ensemble
# reclassify our ensemble prediction
quemin_SDM_ensemble[] <- ifelse(quemin_SDM_ensemble[] >= threshold_sel, 1, 0)
Plot the distribution of *Quercus minima*
plot(quemin_SDM_ensemble)
plot(countriesCoarse, add = TRUE)
plot(quemin_SDM_ensemble)
dir.create("Results/SDMs")
writeRaster(quemin_SDM_ensemble,
filename = "Results/SDMs/quemin_SDM_Ensemble",
format = "GTiff",
bylayer = TRUE,
overwrite = TRUE)
mapTheme <- rasterTheme(region = rev(brewer.pal(11, "Spectral")),
layout.widths = list(right.padding = 10),
axis.line = list(col = "transparent"),
tick = list(col = 'transparent'))
library(rasterVis)
library(RColorBrewer)
mapTheme <- rasterTheme(region = rev(brewer.pal(11, "Spectral")),
layout.widths = list(right.padding = 10),
axis.line = list(col = "transparent"),
tick = list(col = 'transparent'))
levelplot(quemin_ENM_ensemble,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = FALSE),
y = list(draw = FALSE)),
zlim = c(0, 1))
grid::grid.text('Quercus minima \n Probability of presence',
rot = 90,
y = unit(0.5, "npc"),
x = unit(0.925, "npc"),
gp = grid::gpar(fontsize = 15))
levelplot(quemin_ENM_ensemble,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = FALSE),
y = list(draw = FALSE)),
zlim = c(0, 1))
levelplot(quemin_ENM_ensemble,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = FALSE),
y = list(draw = FALSE)),
zlim = c(0, 1))
grid::grid.text('Quercus minima \n Probability of presence',
rot = 90,
y = unit(0.5, "npc"),
x = unit(0.925, "npc"),
gp = grid::gpar(fontsize = 15))
levelplot(quemin_ENM_ensemble,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = FALSE),
y = list(draw = FALSE)),
zlim = c(0, 1))
levelplot(quemin_ENM_ensemble,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = FALSE),
y = list(draw = FALSE)),
zlim = c(0, 1))
