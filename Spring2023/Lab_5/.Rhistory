geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = 'darkgray')
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = 'darkgray') +
geom_spatial_point(data = quemin_spt)
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = 'darkgray') +
geom_spatial_point(data = quemin_spt, aes(x = decimalLongitude, y = decimalLatitude)) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = 'darkgray') +
geom_point(data = quemin, aes(x = decimalLongitude, y = decimalLatitude)) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = 'darkgray') +
geom_point(data = occ_quemin, aes(x = decimalLongitude, y = decimalLatitude)) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'darkgray', fill = 'darkgray') +
geom_point(data = occ_quemin,
aes(x = decimalLongitude, y = decimalLatitude),
color = "darkgray", alpha = 0.5) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'lightgray', fill = 'lightgray') +
geom_point(data = occ_quemin,
aes(x = decimalLongitude, y = decimalLatitude),
color = "darkgray", alpha = 0.5) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "darkgray", alpha = 0.5) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
#| eval: false
quemin_thinned <- thin(
loc.data =  occ_quemin,
verbose = FALSE,
long.col = "decimalLongitude",
lat.col = "decimalLatitude",
spec.col = "scientificName",
thin.par = 2, # points have at least a minimum distance of 2 km from each other
reps = 1,
locs.thinned.list.return = TRUE,
write.files = FALSE,
out.dir = "Data/OCC/")
quemin_thinned <- as.data.frame(quemin_thinned)
quemin_thinned$Species <- "Quercus_minima"
#| eval: false
glimpse(quemin_thinned)
#| eval: false
quemin_thinned_sf <- st_as_sf(quemin_thinned,
coords = c("Longitude", "Latitude"),
crs = 4326) %>%
st_cast("MULTIPOINT")
# The below code is using R base. We will use this object for the modelling part
quemin_thinned_spt <- SpatialPointsDataFrame(coords = quemin_thinned[, 1:2],
data = quemin_thinned,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
#| eval: false
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "blue", alpha = 0.5) +
geom_sf(data = quemin_thinned_sf, color = "red", alpha = 0.3) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
rm(gbif_data, occ_quemin, quemin_spt)
bios <- raster::getData("worldclim", var = "bio", res = 10,
download = TRUE, path = "Data/Envi")
#| eval: false
names(bios)
str(bios[[1]])
#| eval: false
plot(stack(bios$bio1, bios$bio12))
#| eval: false
bios_US <- crop(bios, map_US)
map_US
extent(map_US)
as(map_US, "spatial")
as(map_US, "Spatial")
#| eval: false
USpoly_spt <- subset(countriesCoarse, ADMIN == "United States of America") # used as extent
plot(USpoly_spt)
#| eval: false
bios_US <- crop(bios, USpoly_spt)
#| eval: false
plot(bios_US[[1]]) # mean annual temperature
plot(quemin_thinned_spt, col = "red", pch = 16, add = TRUE) # add occurrence records
plot(countriesCoarse, lwd = 2, lty = 2, add = TRUE) # add country borders
#| eval: false
#gbif_data
# if, for any species, "Records found" is larger than "Records returned", you need to increase the 'limit' argument above -- see help(occ_data) for options and limitations
# check how the data are organized:
names(gbif_data)
head(occ_quemin)
load("Data/OCC/oaks_raw_occ.RDATA")
#| eval: false
#gbif_data
# if, for any species, "Records found" is larger than "Records returned", you need to increase the 'limit' argument above -- see help(occ_data) for options and limitations
# check how the data are organized:
names(gbif_data)
names(gbif_data[[2]]$meta)
names(gbif_data[[2]]$data)
#| eval: false
# get the columns that matter for mapping and cleaning the occurrence data:
occ_quemin <- gbif_data[[2]]$data[, c("decimalLongitude", "decimalLatitude",
"scientificName", "occurrenceStatus",
"coordinateUncertaintyInMeters",
"institutionCode", "references")]
head(occ_quemin)
#| eval: false
glimpse(occ_quemin)
# It look like the data include two species, let's clean the data first
occ_quemin <- occ_quemin %>%
filter(scientificName == "Quercus minima (Sarg.) Small")
glimpse(occ_quemin)
#| eval: false
occ_quemin <- occ_quemin %>%
filter(!is.na(decimalLongitude & !is.na(decimalLatitude)))
#occ_quealb <- subset(occ_quealb, !is.na(decimalLongitude) & !is.na(decimalLatitude))
occ_quemin
#| eval: false
occ_quemin <- coord_incomplete(coord_imprecise(coord_impossible(coord_unlikely(occ_quemin))))
occ_quemin
#| eval: false
glimpse(occ_quemin)
## 537    7
#| eval: false
quemin_spt <- st_as_sf(occ_quemin,
coords = c("decimalLongitude", "decimalLatitude"),
crs = 4326) #%>%
#st_cast("MULTIPOINT")
# explore the data
glimpse(quemin_spt)
#| eval: false
sf_use_s2(FALSE)
# world map
worldMap <- rnaturalearth::ne_countries(scale = "medium",
type = "countries",
returnclass = "sf")
# country subset
USpoly <- worldMap %>%
#filter(region_wb == "North America")
filter(admin == "United States of America")
#| eval: false
map_US <- map_data('world')[map_data('world')$region == "USA", ]
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_polygon(data = map_US,
aes(x = long, y = lat, group = group),
color = 'lightgray', fill = 'lightgray') +
geom_point(data = occ_quemin,
aes(x = decimalLongitude, y = decimalLatitude),
color = "darkgray", alpha = 0.5) +
coord_map() +
coord_fixed(1.3,
xlim = c(-65, -125),
ylim = c(50, 25)
) +
theme(panel.background = element_rect(fill = "lightblue"))
#| eval: false
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "darkgray", alpha = 0.5) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
#| eval: false
quemin_thinned <- thin(
loc.data =  occ_quemin,
verbose = FALSE,
long.col = "decimalLongitude",
lat.col = "decimalLatitude",
spec.col = "scientificName",
thin.par = 2, # points have at least a minimum distance of 2 km from each other
reps = 1,
locs.thinned.list.return = TRUE,
write.files = FALSE,
out.dir = "Data/OCC/")
quemin_thinned <- as.data.frame(quemin_thinned)
quemin_thinned$Species <- "Quercus_minima"
#| eval: false
glimpse(quemin_thinned)
#| eval: false
quemin_thinned_sf <- st_as_sf(quemin_thinned,
coords = c("Longitude", "Latitude"),
crs = 4326)
# The below code is using R base. We will use this object for the modelling part
quemin_thinned_spt <- SpatialPointsDataFrame(coords = quemin_thinned[, 1:2],
data = quemin_thinned,
proj4string = CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"))
#| eval: false
ggplot() +
geom_polygon(data = map_data("world"),
aes(x = long, y = lat, group = group),
color = "#f1f2f3", fill = '#f3f3f3') +
geom_sf(data = USpoly) +
geom_sf(data = quemin_spt, color = "blue", alpha = 0.5) +
geom_sf(data = quemin_thinned_sf, color = "red", alpha = 0.3) +
coord_sf(
xlim = c(-125, -65),
ylim = c(25, 50)
) +
theme(
plot.background = element_rect(fill = "#f1f2f3"),
panel.background = element_rect(fill = "lightblue"),
panel.grid = element_blank(),
line = element_blank(),
rect = element_blank()
)
rm(gbif_data, occ_quemin, quemin_spt)
#| eval: false
names(bios)
str(bios[[1]])
#| eval: false
plot(stack(bios$bio1, bios$bio12))
#| eval: false
USpoly_spt <- subset(countriesCoarse, ADMIN == "United States of America") # used as extent
plot(USpoly_spt)
#| eval: false
bios_US <- crop(bios, USpoly_spt)
#| eval: false
plot(bios_US[[1]]) # mean annual temperature
plot(quemin_thinned_spt, col = "red", pch = 16, add = TRUE) # add occurrence records
plot(countriesCoarse, lwd = 2, lty = 2, add = TRUE) # add country borders
#| eval: false
### Species specific accessible area
bb <- bbox(quemin_thinned_spt) # bounding box
e <- extent(c(bb[1]-3, bb[3]+3, bb[2]-3, bb[4]+3)) # bounding box + 300 km
p <- as(e, 'SpatialPolygons') # transform to polygon
crs(p) <- crs(bios_US) # use the geographical reference of the bioclimatic variables
crs(USpoly_spt) <- crs(bios_US)
out <- gIntersection(USpoly_spt, p, byid = FALSE) # use NAs to eliminate areas on the sea
#| eval: false
plot(bios_US[[1]])
plot(p, add = TRUE, lty = 2)
plot(out, add = TRUE, lwd = 2)
#enviSPP <- raster::crop(envi, out)
#| eval: false
bios_spp <- raster::crop(bios_US, out)
bios_spp <- raster::mask(bios_spp, out)
# plot the results
plot(bios_spp[[1]])
plot(quemin_thinned_spt, add = TRUE, col = "red", pch = 16)
plot(USpoly_spt, add = TRUE, lty = 2)
#| eval: false
set.seed(12345) # Random Number Generation to obtain the same result
# Generate the data
absence <- randomPoints(mask = bios_spp[[1]],
n = round(nrow(quemin_thinned)*2, 0), # number of pseudoabsences
p = quemin_thinned_spt, # presence object
ext = extent(bios_spp) # extent
)
#| eval: false
# Presences
presence <- data.frame(quemin_thinned) # presence data
# Pseudoabsences
absence <- data.frame(absence) # pseudoabsence data
absence$Species <- "Quercus_minima"
names(absence) <- names(presence)
presence$Occurrence <- 1 # presence data
absence$Occurrence <- 0 # pseudoabsence data
quemin <- rbind(presence, absence) # combine both information
#| eval: false
coordinates(quemin) <- ~ Longitude + Latitude
crs(quemin) <- crs(bios_spp)
quemin
#| eval: false
plot(bios_spp[[1]])
plot(quemin[quemin$Occurrence == 1, ], col = "blue", add = TRUE, pch = 16)
points(quemin[quemin$Occurrence == 0, ], col = "red", pch = 16)
rm(absence, presence, bios, e, out, p, bb)
#| eval: false
quemin_bios <- data.frame(raster::extract(bios_spp, quemin))
quemin_bios <- cbind(data.frame(quemin), quemin_bios)
quemin_bios <- quemin_bios[complete.cases(quemin_bios), ]
quemin_bios <- na.omit(quemin_bios)
glimpse(quemin_bios)
#| eval: false
cor_mat <- cor(quemin_bios[, c(6:24)], method = 'spearman')
#| eval: false
corrplot::corrplot.mixed(cor_mat,
tl.pos = "lt",
tl.cex = 0.5,
number.cex = 0.5,
addCoefasPercent = TRUE,
mar = c(0, 0, 1, 0))
#| eval: false
# Run select07()
covar_sel <- mecofun::select07(X = quemin_bios[, -c(1:5)], # only predictors data
y = quemin_bios$Occurrence, # presence-absence data
threshold = 0.7) # here you can change the threshold for one
# Check out the structure of the resulting object:
str(covar_sel)
#| eval: false
covar_sel$AIC
covar_sel$cor_mat
covar_sel$pred_sel
#| eval: false
preds <- covar_sel$pred_sel
preds
#| eval: false
bios_quemin_sel <- bios_spp[[preds]]
plot(bios_quemin_sel)
#| eval: false
quemin_DATA <- sdmData(formula = Occurrence ~ bio2 + bio5 + bio8 + bio9 + bio10 + bio12 + bio14 + bio18,
train = quemin, # presence-pseudoabsence data
predictors = bios_quemin_sel, # selected covariables
crs = crs(bios_quemin_sel))
#| eval: false
quemin_DATA
#| eval: false
getmethodNames('sdm')
#| eval: false
#This takes sometime (~3 minutes) please be patient!
quemin_SDM <- sdm(Occurrence~., # the presence-absence
data = quemin_DATA, # formula and data
methods = c("bioclim", "domain.dismo", "glm", "gam", "rf", "svm"), # algorithms
replication = "sub", test.percent = 30, n = 2, # training-testing subsampling
parallelSettings = list(ncore = 2, method = "parallel")) # parallel computation
#| eval: false
quemin_SDM
quemin_SDM@run.info
quemin_SDM@models$Occurrence$bioclim$1
?sdm
getVarImp(quemin_SDM)
getVarImp(quemin_SDM, method = "glm")
getVarImp(quemin_SDM, method = "rf")
getEvaluation(quemin_SDM)
getEvaluation(quemin_SDM, method = "glm")
getEvaluation(quemin_SDM, wtest = "testing")
getEvaluation(quemin_SDM, wtest = "trining")
getEvaluation(quemin_SDM, wtest = "trining", stat = 1)
getEvaluation(quemin_SDM, wtest = "trining", stat = 2)
getEvaluation(quemin_SDM, w = 1, wtest = "trining", stat = 2)
getEvaluation(quemin_SDM,opt=1)
getEvaluation(quemin_SDM,stat=c('TSS','Kappa','AUC'),opt=1)
?varImpPlot
?varImp
# Get the
getVarImp(quemin_SDM)
# Get the variable importance for a specific algorithm
getVarImp(quemin_SDM, method = "rf") # VI for Random Forest algorithm
#| eval: false
quemin_ENM_bioclim <- predict(quemin_SDM, #sdm object
newdata = bios_quemin_sel, # environmental data
method = "bioclim", # algorithm
mean = TRUE)
quemin_ENM_bioclim
#| eval: false
quemin_ENM_bioclim <- sdmvspecies::rescale(quemin_ENM_bioclim$sp_1.m_bioclim.re_subs)
plot(quemin_ENM_bioclim)
#| eval: false
quemin_ENM_domain <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "domain.dismo", mean = TRUE)
quemin_ENM_glm <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "glm", mean = TRUE)
quemin_ENM_gam <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "gam", mean = TRUE)
quemin_ENM_rf <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "rf", mean = TRUE)
quemin_ENM_svm <- predict(quemin_SDM, newdata = bios_quemin_sel,
method = "svm", mean = TRUE)
# Please, do not pay attention to the warnings...
#| eval: false
quemin_ENM_domain <- sdmvspecies::rescale(quemin_ENM_domain$sp_1.m_domain.dismo.re_subs)
quemin_ENM_glm <- sdmvspecies::rescale(quemin_ENM_glm$sp_1.m_glm.re_subs)
quemin_ENM_gam <- sdmvspecies::rescale(quemin_ENM_gam$sp_1.m_gam.re_subs)
quemin_ENM_rf <- sdmvspecies::rescale(quemin_ENM_rf$sp_1.m_rf.re_subs)
quemin_ENM_svm <- sdmvspecies::rescale(quemin_ENM_svm$sp_1.m_svm.re_subs)
#| eval: false
quemin_ENM_all <- raster::stack(quemin_ENM_bioclim, quemin_ENM_domain,
quemin_ENM_glm, quemin_ENM_gam,
quemin_ENM_svm, quemin_ENM_rf)
names(quemin_ENM_all) <- c("Bioclim", "Domain", "GLM", "GAM", "SVM", "RF")
#| eval: false
plot(quemin_ENM_all)
#| eval: false
### Ensemble prediction - ensemble based on TSS statistics
quemin_ENM_ensemble <- ensemble(quemin_SDM, # sdm object
newdata = bios_quemin_sel, # covariables
method = c("rf", "gam", "svm", "glm"),# algorithms
setting = list(method = "weighted", stat = "TSS"), # metric
parallelSettings = list(ncore = 2, method = "parallel"))
#| eval: false
quemin_ENM_ensemble <- sdmvspecies::rescale(quemin_ENM_ensemble)
#| eval: false
plot(quemin_ENM_ensemble)
#| eval: false
library(rasterVis)
library(RColorBrewer)
mapTheme <- rasterTheme(region = rev(brewer.pal(11, "Spectral")),
layout.widths = list(right.padding = 10),
axis.line = list(col = "transparent"),
tick = list(col = 'transparent'))
levelplot(quemin_ENM_ensemble,
maxpixels = 1e10,
margin = FALSE,
par.settings = mapTheme,
scales = list(x = list(draw = FALSE),
y = list(draw = FALSE)),
zlim = c(0, 1))
#| eval: false
dt <- data.frame(as.data.frame(quemin_DATA), coordinates(quemin_DATA))
glimpse(dt)
prediction <- raster::extract(quemin_ENM_ensemble, dt[, c("Longitude", "Latitude")])
evaluation <- sdm::evaluates(dt$Occurrence, prediction) # observed versus expected
threshold_sel <- evaluation@threshold_based$threshold[2]
round(threshold_sel, 2)
#| eval: false
quemin_SDM_ensemble <- quemin_ENM_ensemble
# reclassify our ensemble prediction
quemin_SDM_ensemble[] <- ifelse(quemin_SDM_ensemble[] >= threshold_sel, 1, 0)
#| eval: false
plot(quemin_SDM_ensemble)
plot(countriesCoarse, add = TRUE)
