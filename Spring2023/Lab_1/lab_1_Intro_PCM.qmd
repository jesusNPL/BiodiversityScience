---
title: "Introduction to Phylogenies and the Comparative Method"
description: Showing some neat features of R!
date: today # other options: now, last-modified
author:
  - name: Jesús N. Pinto-Ledezma and Jeannine Cavender-Bares 
    url: https://jesusnpl.github.io
    affiliation: Ecology, Evolution & Behavior, University of Minnesota
                Biodiversity Science - EBB (5534)
    affiliation-url: https://github.com/jesusNPL/BiodiversityScience
title-block-banner: true
#title-block-banner: "#562457"
format: 
  html: 
    embed-resources: true # save contained file.
    theme: darkly # check other themes https://quarto.org/docs/output-formats/html-themes.html
    code-fold: true
    toc: true
    number-sections: true
bibliography: lab_0_PCM.bib
link-citations: yes
csl: ../apa-single-spaced.csl
---

:::{.callout-note}
In this lab, you will learn basic tools in R for visualizing phylogenies, optimizing ancestral states for a discrete and continuous characters, testing models of character evolution, and performing phylogenetic correction of a regression model. This lab is based in part on one designed by Luke Harmon for a workshop that he and others ran; the original can be seen [here](http://lukejharmon.github.io/ilhabela/instruction/2015/07/03/PGLS/) There are many other useful labs in comparative analysis from that [workshop](http://lukejharmon.github.io/ilhabela/) that you can peruse at your leisure. 
:::

You will need two datasets, that will be provided for you:
  1. A data.frame with species traits **furnariides_traits.csv**
  2. A phylogenetic tree **furnariides_tree.csv**

The clade we will work on today is the **Furnariides/Aves**, also known as the largest continental endemic radiation [@pinto-ledezma_drivers_2019]. The trait data correspond to several morphological measurements of birds from **AVONET** [@tobias_avonet_2022].

# Set up your data and your working directory

You will need to have a set of R packages to do this lab. Install the following packages:

```{r}
packages <- c("tidyverse", "ape", "geiger", "nlme", "phytools", "rr2") 
# Package vector names
```

:::{.callout-tip}
## Function install.packages()
You can use the function **install.packages()** to install the packages.
:::

If you don't want to install the packages one by one, you can use the next command 
```{r}
# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())

if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages], dependencies = TRUE)
}
```

Load installed packages

```{r}
library(tidyverse)
library(ape)
library(geiger)
library(nlme)
library(phytools)
library(rr2)
```

Set up a working directory and put the two data files in that directory. Tell R that this is the directory you will be using, and read in your data:

```{r}
#| eval: false
setwd("path/for/your/directory")
```

```{r}
## Trait data
furnaData <- read_csv("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2023/Lab_1/Data/furnariides_traits.csv") %>% 
  column_to_rownames("Sciname") %>%   # we are using the column "Sciname" as rownames
  drop_na(Range.Size)

## Phylogenetic data
furnaTree <- read.nexus("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2023/Lab_1/Data/furnariides_tree.nex")
```
OK. You should be ready to go.

let's inspect the data first, to do that we will use the function **"glimpse()"** of the R package **{dplyr}** 

```{r}
glimpse(furnaData)
```

Let's check if our trait data contain the same species as in the phylogeny

```{r}
tmp <- name.check(phy = furnaTree, data = furnaData)
tmp
```

It indicate that the species *Philydor novaesi* is not present in the trait data, so let's drop this species from the phylogeny.

```{r}
furnaTree <- drop.tip(phy = furnaTree, tip = tmp$tree_not_data)
```

We can double check if our data match after dropping the missing species

```{r}
name.check(phy = furnaTree, data = furnaData)
```

Now it seems that we are ready to go!

# Working with trees

Let’s start by looking at the phylogeny of these lizards and learning a bit about how to work with trees in R. 

*What does your tree look like?*

```{r}
plot(furnaTree)
```

Whoa. That's ugly. Let's clean it up.

```{r}
plot.phylo(furnaTree, no.margin = TRUE, cex = 0.5)
```

Better. You can mess around with tree plotting functions in plot.phylo() as much as you'd like. Try this for example:

```{r, eval = FALSE}
plot.phylo(anoleTree, type = "fan", no.margin = TRUE, cex = 0.7)
```

Pretty.

It may be useful to understand how trees are encoded in R. Typing in just the name of the tree file like this:

```{r}
furnaTree
```

will give you basic information about the phylogeny: the number of tips and nodes; what the tips are called; whether the tree is rooted; and if it has branch lengths.

```{r}
str(furnaTree)
```

will tell you more about tree structure. Trees consist of tips connected by edges (AKA branches)

```{r}
furnaTree$tip.label
```

gives you a list of all your terminal taxa, which are by default numbered 1-n, where n is the number of taxa.

```{r}
furnaTree$Nnode
```

gives you the number of nodes. This is a fully bifurcating rooted tree, so it has 1 fewer node than the number of taxa.

```{r, eval = FALSE}
furnaTree$edge
```

This tells you the beginning and ending node for all edges.
Put that all together with the following

```{r, eval = FALSE}
plot.phylo(furnaTree, type = "fan", no.margin = TRUE, cex = 0.7, label.offset = 0.1)
nodelabels(cex = 0.5)
tiplabels(cex = 0.5)
```

There are many ways to manipulate trees in R using **{Ape}**, **{Phytools}**, and other packages. This just gives you a bare-bones introduction.

# Working with a data matrix and testing hypotheses in a phylogenetically informed way

Let's ask some questions using the trait data that were measured for these lizards. First, explore the data in the "anoleData" matrix. Here are some options for visualizing data matrices:

```{r}
furnaData %>% 
  head() # this will show you the first few rows of your data matrix and its header

furnaData %>% 
  dimnames() # this will show you the row and column headers for your matrix

furnaData %>% 
  View() # this will let you visualize the entire matrix
```
After looking at the data, please answer the next questions

*What variables were measured for each of these species of Furnariides? How many species of Furnariides were used?* 

*Is that the same number that were in your phylogeny?*

**Hand-wing index** is one of your variables. Let's isolate it so we can work with it easily:

```{r}
hwi <- furnaData[, "Hand-Wing.Index"]
names(hwi) <- rownames(furnaData) 
# data vectors have to be labelled with tip names for the associated tree. 
# This is how to do that.
```


:::{.callout-tip}
## Exploring the data
It is good practice to revise the distribution of your data before doing downstream analysis. 
:::

```{r}
hist(hwi)
```


In lecture, Brie talked about one model of character evolution, called a Brownian Motion model. This model assumes that a trait evolves from a starting state (**z0**) according to a random walk with the variance specified by the rate parameter $\sigma^{2}$ (**sigma-squared**). In short, Brownian motion describes a process in which tip states are modeled under the assumption of a multivariate normal distribution. On a phylogeny, the multivariate mean of tip states is equal to the root state estimate, and variance accumulates linearly through time.

*What does Brownian Motion evolution of Awesomeness in lizards look like?*

```{r}
brownianModel <- fitContinuous(furnaTree, hwi)
brownianModel # this will show you the fit statistics and parameter values
```


Here, you can see the estimates for ancestral state (z0), and the rate parameter ($\sigma^{2}$), as well as some measures of model fit. The fit of the model is determined using maximum likelihood, and expressed as a log likelihood. The higher the **lnL**, the more probable the data given the model. However, when comparing different models, we can't use the **lnL**, because it does not account for the difference in the number of parameters among models. Models with more parameters will always fit better, but do they fit significantly better? For example an OU model has 4 parameters (alpha [$\alpha$], theta [$\theta$], z0, and sigma-squared [$\sigma^{2}$]), so it should fit better than a BM model, which includes only z0 and sigsq. To account for this, statisticians have developed another measure of fit called the AIC (Akaike Information Criterion): **AIC = (2xN)-2xlnL**, where **N** is the number of parameters. This penalizes the likelihood score for adding parameters. When selecting among a set of models, the one with the lowest AIC is preferred. We will use this information later on in this lab.

In addition to assessing model fit, we can use the Brownian Motion model to reconstruct ancestral states of a character on a tree. To visualize what BM evolution of this trait looks like on a tree. The *contMap()* command in phytools estimates ancestral states and plots them on a tree.

```{r}
contMap(furnaTree, hwi, fsize = 0.5, lwd = 3)
```

*Describe the evolution of body mass on this tree. How many times have exteremely high and extremely low body mass evolved on this tree?*

*What does this say about our ability to test hypotheses about the evolution of body mass?*

Let’s go ahead and test some hypotheses. **Range Size** is another trait in your data matrix. Let’s assess whether there is a correlation between HWI and body mass? We will extract the column "WHI" from the datamatrix and assign it species names, just as we did for "body mass" above.

```{r}
rangeSize <- furnaData[, "Range.Size"]
names(rangeSize) <- rownames(furnaData)
```

Let’s look at a plot of range size as a function of hand-wing index.

```{r}

furnaData %>% 
  drop_na(Range.Size) %>% 
  ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) + 
  geom_point(alpha = 0.5, color = "darkgray") + 
  labs(x = "Hand-Wing Index", y = "log(Range Size)")

```

Hm. looks promising. *How would you describe the relationship between these two variables?*

Let's be more quantitative in describing that relationship with a linear model.

```{r, eval = FALSE, fig.keep = 'all'}

lm_hwi_rangesize <- lm(log(rangeSize) ~ hwi)
summary(lm_hwi_rangesize)
```

```{r, eval = FALSE, fig.keep = 'all'}
furnaData %>% 
  drop_na(Range.Size) %>% 
  ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) + 
  geom_point(alpha = 0.5, color = "darkgray") + 
  labs(x = "Hand-Wing Index", y = "log(Range Size)") + 
  geom_smooth(method = "lm")

```

The coefficients table from the *summary()* command shows the slope and intercept for the linear model describing **range size** as a function of **hand-wing index**. Each line shows the estimated coefficient (Estimate), the standard error (Std. Error) of that estimate, as well as a t-statistic and associated p-value, testing whether those parameters are equal to 0. The Multiple R-squared is an estimate of how much variance in the response variable can be explained by the predictor variable.

*Write the linear model for this relationship. Are the parameters significantly different from 0?* 

*What is the R^2 value for this data?* 

*How do you feel about that?*

Nice. But. We have not considered the fact that these birds are related to each other. As such, they may share their hand-wing index and range size simply due to the fact that their ancestors had large HWI and range size. In other words, we need to account for non-independence of residuals due to phylogeny. One way to do that is to use phylogenetic-generalized-least-squares regression (PGLS).

```{r, eval = FALSE}
pglsModel <- gls(log(rangeSize) ~ hwi, 
                 correlation = corBrownian(phy = furnaTree, form=~names(rangeSize)), 
                 method = "ML")
```

Let's break this command down. This command infers a linear model for awesomeness as a function of hostility (gls(awe ~ host), but it specifies existing correlation structure in the data (correlation =) as the covariance of these traits assuming a Brownian motion model (corBrowinan()) based on the anolis tree (phy = anoleTree) and a correctly ordered list of taxon names (form=~names(awe)). The model is fit using maximum likelihood (method = "ML"). To see the results:

```{r}
summary(pglsModel)
coef(pglsModel)
R2(pglsModel)
```

```{r}

furnaData %>% 
  drop_na(Range.Size) %>% 
  ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) + 
  geom_point(alpha = 0.5, color = "darkgray") + 
  labs(x = "Hand-Wing Index", y = "log(Range Size)") + 
  #geom_smooth(method = "lm") + 
  geom_abline(intercept = coef(pglsModel)[1], slope = coef(pglsModel)[2], 
              color = "red", linewidth = 1.5)

# will plot the pgls regression line on your biplot.
```

*Write the linear model for this relationship. Are the parameters significantly different from 0?*

*What is the R^2 value for this data? (use the likelihood-based R^2 value)* 

*How do you feel about that?* 

*Compare results from the pgls analysis with those that you got from the regular linear model you ran earlier.*

# Model Fitting

Brownian Motion is only one model of evolution for a continuous variable. Another model is the **Ornstein-Uhlenbeck (OU)** model, which allows the trait mean to evolve towards a new state (theta), with a selective force (alpha). These two new parameters, plus the starting state (z0) and the rate of evolution (sigsq) parameters from the BM model, make for a 4-parameter model. The **Early Burst (EB)** model allows the rate of evolution to change across the tree, where the early rate of evolution is high and declines over time (presumably as niches are filled during an adaptive radiation. The rate of evolution changes exponentially over time and is specified under the model r[t] = r[0] x exp(a x t), where r[0] is the initial rate, a is the rate change parameter, and t is time. The maximum bound is set to -0.000001, representing a decelerating rate of evolution. The minimum bound is set to $log(10^{-5})$/depth of the tree.

Let’s evaluate the relative fit of these three models to the Awesomeness trait.

```{r}
brownianModel <- fitContinuous(furnaTree, hwi)
```

```{r}
OUModel <- fitContinuous(furnaTree, hwi, model = "OU")
```

```{r}
EBModel <- fitContinuous(furnaTree, hwi, model = "EB")
```

And recover the parameter values and fit estimates.

```{r}
brownianModel
OUModel
EBModel
```

Compare all models and select the best fitting model.

```{r}
aicw(c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc))
```


*Make a table with the AIC and lnL values for each model. Which model provides the best fit for awesomeness?* 

*Now, add the results for a model fitting analysis of the Hostility trait to this table.*

So, we were wrong. An OU model fits HWI better (and you should be able to explain how we know that). Unfortunately, a PGLS analysis with an OU model specified is currently computationally difficult. The best we can do is report the results from our model fitting analysis, and realize that the parameters from BM might not be the best fit.

However, we can still test our hypothesis that species with large HWI also present large range size, and account for phylogeny when we do. First, we should compare the uncorrected linear model of range size as a function of HWI vs the PGLS that uses the covariance structure of the residuals under a Brownian Motion model.

```{r}

furnaData %>% 
  drop_na(Range.Size) %>% 
  ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) + 
  geom_point(alpha = 0.5, color = "darkgray") + 
  labs(x = "Hand-Wing Index", y = "log(Range Size)") + 
  geom_smooth(method = "lm") + 
  geom_abline(intercept = coef(pglsModel)[1], slope = coef(pglsModel)[2], 
              color = "red", linewidth = 1.5)

```

You might want to know if these regressions really differ in their ability to predict range size from HWI. Asked in another way, are the slopes from these two regressions significantly different from each other? You need to know that a 95% confidence interval for the slope parameter is b (the slope) plus/minus 1.96 standard errors (this is derived from a normal distribution). To calculate your 95% confidence intervals:

```{r, eval = FALSE}
rshwi.sum <- summary(lm_hwi_rangesize)

#for the uncorrected linear model
rshwi.sum$coef[2, 1] + c(-1.96, 1.96)*rshwi.sum$coef[2, 2]

#for Brownian Motion, the 95% CI
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])

```

*Did phylogenetic correction make a difference in this case?* 

*What do you conclude about the evolution of awesomeness as a function of hostility?*

# Discrete Character Mapping

So far, we have been dealing with continuous characters, those that take values along some continuum. Things like height, weight, length, temperature, humidity, etc. are continuous variables. There is another type of variable called a discrete variable, that takes, well, discrete values. Color (e.g. red, blue, green); Locomotory type (e.g. scansoial, terrestrial, fossorial) are examples of discrete variables.

Look at the data in the furnaData matrix. *Which of these variables are discrete and which are continuous?*

In your data matrix, **Habitat** has been coded for each of these species. Let’s examine some biogeography for these birds by reconstructing the ancestral habitat (i.e. area of origin) and dispersal history. First, isolate your variable.

```{r}
habitat <- furnaData$Habitat
names(habitat) <- rownames(furnaData)
```

We can simultaneously fit a model of discrete character evolution and create a set of plausible character histories using a method called stochastic character mapping:

```{r, eval = FALSE}
habitat_anc <- make.simmap(furnaTree, habitat, model = "SYM", nsim = 100)
```

This analysis results in a "Q" matrix showing the relative probabilities of change from state to state. For this character, this would represent dispersal events between islands. The higher the value, the higher the probability of that type of change.

*Which pair of islands shows the highest probability of interchange?* 

*Which pair shows the least?* 

*Does this make sense geographically?*

Now, you can plot a random simulation of change in this character, that is based on the values inferred above.

```{r, eval = FALSE}
plotSimmap(island_anc[[1]], fsize = 0.5) # this plots the first of 100 simulations
```

*How many transitions are there between black and red?* 

*Are there any reversals?* 

*Are there any branches with more than one change?* 

*Using the command above, but changing the index from 1 to other values, look at a number of reconstructions. How much variation do you see?*

We can summarize these simulations and estimate the relative probability of each island as an ancestor for each node on our tree:

```{r, eval = FALSE}
island_summary <- summary(island_anc)
plot(island_summary, cex = c(0.5, 0.2), fsize = 0.5, offset = 90)
legend("bottomleft", fill = c("black", "red", "green", "blue"), 
       legend = c("Cuba", "Hispanola", "Jamaica", "PR"))
```

*Where did Anoles likely originate?* 

*How many transitions from Cuba to Hispanola?* 

*Are there any reversals?* 

*Does a Jamaican ancestor ever move to Puerto Rico?* 








R is a language and a statistical programming environment and graphics or also called an **“object-oriented programming”**, which means that using R involves the creation and manipulation of objects on a screen, where the user has to say exactly what they want to do rather than simply press a button **(black box paradox)**. So, the main advantage of R is that the user has control over what is happening and also a full understanding of what they want before performing any analysis.

With R, it is possible to manipulate and analyze data, make graphics and write from small commands to entire programs. Basically, R is the open version of the S language, created by Bell’s Lab in 1980. Interestingly, the S language is super popular among different areas of science and is the base for commercial products such as SPSS, STATA, and SAS, among others. Thus, if we have to add another advantage to R, is that R is an **open language and free**!

There are different sources and web-pages with a lot of information about R, most of them are super useful and can be found at [DataCamp](https://www.datacamp.com/), [CRAN](https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf), [R Tutorial](http://www.r-tutor.com/r-introduction).

Also, when we are reporting our results in the form of a report, scientific paper or any kind of document, we would need to cite the used software, the easiest to cite R is using the internal function **citation()**.

```{r}
citation()
```

# First steps

First that all, we need to know about **WHERE** are we working at. In other words, our working directory. To get information that information we just need to type **getwd()** in the script or the console.

```{r}
getwd()
```

If the working directory is not the correct one, we just need to order R to **SET** the correct address.

```{r}
#| eval: false
setwd("Your path or directory")
```

There is an R package called **{here}** that is super convenient for setting your working directory if the path is really long. You didn't hear that from me ;p!

Ok, we are now in the correct place, so we can continue with the practice.

## Directory structure
For training purposes, we will create a **directory structure** where the main folder is our current working environment, so we will create a series of **subfolders** where we store, the data, the scripts and whatever we want… To do that we will use the function **dir.create()**. Let's practice!

:::{.callout-caution collapse="true"}
## Expand to learn more about this issue
Every class you will need to check your working directory in order follow the labs without issues.
:::

```{r}
?dir.create
```

```{r}
#| eval: false
dir.create("BioSci") # this can be your main folder and you can change the name

dir.create("Data") # folder that store the data 

dir.create("R-scripts") # folder that store the scripts used in the course

dir.create("Figures") # folder that store the figures created in the course

dir.create("Results") # The results

dir.create("Temp") 
```

To check if the subfolders were created within the main folder, just use the function **dir()**, this simple function will print in the console the name of the files that are currently in your working directory.

We can SET our working directory into one of the subfolders that we just created using the function **setwd()**

```{r} 
#| eval: false
setwd("Results")
```

However, for practicality it is **super-ultra-mega** recommendable to work in the **MAIN FOLDER**, so go back to the previous folder or main folder by just using the function **setwd()**, instead of using a folder name, we will use simply two dots, yes two dots **".."**. This simple operation will return to the main folder.

```{r} 
#| eval: false
setwd("..")
```

## The importance of the question mark “?” or the help function
Maybe, the most important (at least for Jesús) function of R is **help** or **?**. Using help or the question mark, we can ask to R about almost anything (sadly we can’t order pizza, yet)… so, let's practice!

```{r}
#| eval: false
help("logarithm")
```

```{r}
#| eval: false
?log
```

```{r}
#| eval: false
??log
```

Other important and useful functions in R, are: **head()**, **tail()**, **dim()**, **str**, **summary()**, **names()**, **class()**, **rm()**, **save.image**, **saveRDS() and readRDS()**, **load()**, **source()**, all these simple functions will help us to understand our data.

# Objects: creation and manipulation

In **R** you can create and manipulate different kind of data, from a simple numeric vector to complex spatial and/or phylogenetic data frames. The main six kinds of objects that you can create and manipulate in R, are: vector, factor, matrix, data frame, list and functions. 

So, let's start with the first object, the **Vector**.

## Vector
Vectors are the basic object in R and basically, contains elements of the same type (e.g., numbers, characters). Within vector exist three types: numeric, character and logic.

#### Numeric vector
**IMPORTANT** R is case sensitive, so you need to pay attention when you name the objects.

```{r}
a <- 10 # numeric value 

b <- c(1, 2, 3, 4, 5) # numeric vector

class(b) # ask to R which type of object is b

seq_test <- seq(from = 1, to = 20, by = 2) # Here is a sequence of numbers from 1 to 20, every two numbers

x = seq(10, 30) # This is a sequence from 10 to 30. What is the difference with the previous numeric vector? 

sample(seq_test, 2, replace = T) # Sort two numbers within the object seq_test

rep_test <- rep(1:2, c(10, 3)) # Repeat the number one, ten times and the number 2 three times

ex <- c(1:10) # Create a sequence of 1 to 10

length(ex) # Length of the object example

aa <- length(ex) # What we are doing in here?

str(seq_test) # Look at the structure of the data
```

#### Character vector
We can also create vector of characters, which mean that instead of storing numbers we can store characters.

```{r}
research_groups <- c(Jeannine = "Plants", Jesus = "Birds and plants", Laura = "Plants")

research_groups
```

Explore the character vector using the function **str()**

```{r}
str(research_groups) 
```

You can try to create a different character vector, for example, using the names of your peers.

#### Logic vector
This kind of vector is super useful when the purpose is to create or build functions. The elements of a logic vector are **TRUE, FALSE, NA** (not available).

```{r}
is.factor(ex) # Is it a factor? (FALSE)
```

```{r, warnings = FALSE, message = FALSE}
is.matrix(ex) # Is it a matrix? (FALSE)
```

```{r, warnings = FALSE, message = FALSE}
is.vector(ex) # Is it a vector? (TRUE)
```

```{r, warnings = FALSE, message = FALSE}
a < 1   # 'a' is lower than 1? (FALSE)
```

```{r, warnings = FALSE, message = FALSE}
a == 1   # 'a' is equal to 1? (TRUE)
```

```{r, warnings = FALSE, message = FALSE}
a >= 1   # 'a' is higher or equal to 1? (TRUE)
```

```{r, warnings = FALSE, message = FALSE}
a != 2   # the object 'a' is different of two? (TRUE) (!= negation)
```

## Factor
A factor is useful to create categorical variables, that is very common in statistical analyses, such as the Anova.

```{r}
data <- factor(c("small", "medium", "large"))
```

```{r}
is.factor(data) # Check if the object is correct.
```

## Matrix
A matrix is bidimensional arrangement of **vectors**, where the vectors need to be of the same type, that is, two or more numeric vectors, or two or more character vectors.

```{r}
matx <- matrix(1:45, nrow = 15)
rownames(matx) <-  LETTERS[1:15] # names of the rows
colnames(matx) <- c("Sample01", "Sample02", "Sample03") # names of the columns or headers
```

```{r}
matx # Inspect the matrix
```

```{r}
class(matx) # Ask, which kind of data is?
```

```{r}
matx[, 1] # We can use brackets to select a specific column
```

```{r}
matx[1, ] # We can use brackets to select a specific row
```

```{r}
head(matx)
```

```{r}
tail(matx)
```

```{r}
str(matx)
```

```{r}
summary(matx) # summary statistics of the data in the matrix
```

In general, when we are exploring our data for example using **head()** the function will return only the 6 first rows of our matrix, however, we can add another argument into the function. For example, **head(matx, 10)**, just add the number 10 after the comma and is possible to see the first 10 lines. This simple operation is useful specially when our matrix is large **>100 rows**.

:::{.callout-tip}
## Function tail
You can use the function **tail()** to check the last rows of your data.
:::

## Data frame
The difference between a matrix and a data frame is that a data frame can handle different types of vectors. You can explore more about the data frames asking R **?data.frame**. Let's create a data frame and explore its properties.

```{r}
df <- data.frame(species = c("rufus", "cristatus", "albogularis", "paraguayae"), 
                 habitat = factor(c("forest", "savanna", "urban", "transition")), 
                 high = c(10, 2, 7, 4), distance = c(3, 9, 5, 6))
```

```{r}
class(df)
```

```{r}
matx2 <- as.data.frame(matx) # We can also transform our matrix to a data frame
class(matx2) 
```

```{r}
str(df)
```

## List
The list is an object that consists of an assembly of objects sorted in a hierarchical way. Here we will use the data previously created.

```{r}
lst <- list(data, df, matx)
```

We can now go ahed and inspect the list.

```{r}
str(lst)
```

And also check if the object created is, in fact, a list.

```{r}
class(lst)
```

Now, inspect the objects that are stored into our object **lst**. To do this, we just need to use two brackets **[[]]**.

```{r}
lst[[1]]
```

```{r}
lst[[2]]
```

```{r}
lst[[3]]
```

At to this point, we have explored the most common objects in R. Understanding the structure of each class of objects (from vectors to lists) is maybe the most critical step to learning R.

# Install and load packages

Although R is a programming language, it is also possible to use different auxiliary packages that are available for free to download and to install in our computers.
Install new packages into R is easy and just needs a simple function **install.packages()** and of course, an Internet connection. For more information on how to install new packages, you just need to ask R using **?install.packages**

```{r}
#| eval: false
install.packages("PACKAGE NAME")
```

The reverse function is **remove.packages()**.

Most of the time, we do not remember if we already have a package installed on our computer, so if we are tired and do not want to go to our R folder packages and check if the package is, in fact, installed, we can use the following command.

```{r}
#| eval: false
if ( ! ("PACKAGE NAME" %in% installed.packages())) 
  {install.packages("PACKAGE NAME", dependencies = TRUE)}
```

To load an installed package you can just type, **library() or require()**

```{r}
#| eval: false
library("PACKAGE NAME")
require("PACKAGE NAME")
```

Sometimes we need to install a lot of packages, and installing them one by one will require time and patience, which, most of the time, we don't have Lol. To solve that issue, we can create a vector with the names of the packages and create a simple function that helps us to install R with just one click!

```{r}
# Package vector names
packages <- c("ggplot2", "phytools", "picante", "tidyr", "dplyr") 
```

```{r, eval = FALSE}
#| eval: false
# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
```

Now we can load all the packages listed in last vector.

```{r, eval = FALSE}
#| eval: false
# Packages loading
invisible(lapply(packages, library, character.only = TRUE))
```

:::{.callout-tip}
## R Package {pacman}
{pacman} is an R package that allows you to install and load several packages at once just by using one command line, for example:

pacman::p_load(packages) # packages object is a vector we created before.
:::

# R as a calculator

R can be used as a calculator, for example, we can use the information created before to make some arithmetic operations.

```{r}
b[4]+seq_test[10] # b and seq_test are numeric vectors created before, here we are just
# obtaining the position 4 and 10 from those vectors and summing the values
```

```{r}
b[4]*seq_test[10] # same but multiplying the two values
```

```{r}
seq_test[5]/df[3, 3] # df is a data frame and here we are extracting the value in the 
# row 3 and column 3 and using it as a divisor of the values in the position 5 of the 
# vector seq_test.
```

```{r}
matx[, 3][4]-df[4, 4] # What is difference of this equation compared to the previous?
```

```{r}
seq_test^7 # power function in which each values is raised to the seventh power.
```

```{r}
seq_test*7 # what happen in here?
```

```{r}
seq_test+7
```

```{r}
seq_test-7
```

```{r}
mean(seq_test) # mean value of the numeric vector seq_test
```

```{r}
max(seq_test)
```

```{r}
min(seq_test)
```

```{r}
sum(seq_test)
```

```{r}
log(seq_test)
```

```{r}
sqrt(seq_test)
```

```{r}
cor(matx[, 1], matx[, 2])
```

# Data import/export

As indicated before, using **R** you can handle different kind of information (from vectors to data frames) and basically most of our data is usually stored in an Excel spreadsheet or in files that have the extension of **.csv** (comma-separated values file) or **.txt** (Text X Text or text file that contains unformatted text). 

Most of these files are imported in R are **data frames**, but, as we were practicing, we now have the tools to handle or transform the information into different objects. 

The function to import data to R is simple **read.table()** or **read.csv()**, and using these simple functions, you can import the data and transform it in other kind of objects So, lets practice!

```{r}
dat <- read.table("Data/lab_0/Sample.txt")

dat2 <- read.table("Data/lab_0/Sample.txt", row.names = 1, header = TRUE)

dat3 <- read.csv("Data/lab_0/Sample.csv")
```

```{r}
class(dat)
```

```{r}
class(dat2)
```

```{r}
class(dat3)
```

We can also extract a sample of our data frame.

```{r}
dat3Sample <- dat3[1:50, 1:4]

dim(dat3Sample)
```

We can also import the data frame as a matrix.

```{r}
dat4 <- na.omit(as.matrix(read.csv("Data/lab_0/Sample.csv", row.names = 1, header = TRUE)))
class(dat4)
```

```{r}
head(dat4, 10)
```

```{r}
dat4[1:20, 1:4] # Show the first 20 rows and 4 columns.
```

You can also import your data using the same functions, but without specifying the address. Notice that we do not recommend this procedure as you can't control the **directory structure**, but is useful when you just are exploring data.

```{r}
#| eval: false
dat5 <- na.omit(read.csv(file.choose()))
```

You can also save your data from R using the function **write.table()** or **write.csv()**. Lets save the dat3Sample. Notice that always we need to specify the correct address, in our case we will save the data in the subolder **Data**.

```{r}
#| eval: false
is.na(dat3Sample)

write.csv(dat3Sample, file = "Data/Lab_0/dat3Sample.csv")
```

# Phylogenetic data

To study biodiversity is important to first understand the data we are using and one common data used now is the phylogenetic data or phylogenetic trees that describe the evolutionary relationships between and among lineages. From here until the end of this short tutorial we will try to explain the basics of how to import/export and handle phylogenetic information. You can find extra information in the second chapter of the [MPCM Book](https://www.mpcm-evolution.com/book-sections/part-introduction/2-working-tree-life-comparative-studies-build-tailor-phylogenies-interspecific-datasets).

## Formats
The two most common formats in which the phylogenies are stored are the Newick and Nexus [@10.1093/sysbio/46.4.590]. 

```{r}
"((A:10,B:9)D:5,C:15)F;"
```

Using this notation, the parenthesis links the lineages to a specific node of the tree and the comma **","** separates the lineages that descend from that node. The colon punctuation **":"** can be used after the name of the node and the subsequent numeric values represent the branch length. Finally, the semicolon punctuation **";"** indicate the end of the phylogenetic tree.

Now we can see how this format works, but first, check if we have the R packages for this purpose. Here we will use the R package *Analyses of Phylogenetics and Evolution*, AKA **ape**.

```{r}
if ( ! ("ape" %in% installed.packages())) {install.packages("ape", dependencies = TRUE)}
```

```{r}
require(ape)
```

Now we can read the phylogenetic tree we just created above in Newick format.

```{r}
## Here we will create a phylogenetic tree in Newick format
newick_tree <- "((A:10,B:9)D:5,C:15)F;"

## Read the tre
newick_tree <- read.tree(text = newick_tree)
```

And now we can plot the phylogentic tree

```{r}
plot(newick_tree, show.node.label = TRUE)
```

The other format is the **Nexus**, and after some time using it, we can say that the Nexus format have more flexibility for working. An example of a Nexus format is as follow:

```{r}
"#NEXUS
BEGIN TAXA;
DIMENSIONS NTAXA=3;
TaxLabels A B C;
END;
BEGIN TREES;
TREE=((A:10,B:9)D:5,C:15)F;
END;"
```

We can create and save a nexus file from scratch using the next code.

```{r}
## First create a Nexus file in the working directory 
cat(
 "#NEXUS
 BEGIN TAXA;
 DIMENSIONS NTAXA=3;
 TaxLabels A B C;
 END;
 BEGIN TREES;
 TREE=((A:10,B:9)D:5,C:15)F;
 END;",
file = "../Data/Lab_0/Nexus_tree.nex"
)
```

Now, using the function **read.nexus()** we can read the nexus file.

```{r}
## Now read the phylogenetic tree, but look that instead of using read.tree we are using read.nexus
nexus_tree <- read.nexus("../Data/Lab_0/Nexus_tree.nex")
```

And also plot the imported nexus file.

```{r}
## lets plot the example
plot(nexus_tree, show.node.label = TRUE)
```

Now, let's inspect our phylogenetic trees.

```{r}
str(nexus_tree)
```

```{r}
nexus_tree$tip.label
```

If we want to know about the branch length of the tree we just need to select **edge.lenght**

```{r}
nexus_tree$edge.length
```

An important component of a phylo object is the matrix object called **edge**. In this matrix, each **row** represents a **branch** in the tree and the **first column** shows the index of the ancestral node of the branch and the **second column** shows the descendant node of that branch. Let's inspect!

```{r}
nexus_tree$edge
```

We know it is a little hard to follow even with small trees as the example, but if we plot the phylogenetic tree, the information within it it's easier to understand.

```{r}
# Lets plot the tree
plot(nexus_tree, show.tip.label = FALSE)
# Add the internal nodes
nodelabels()
# Add the tips or lineages
tiplabels()
```

Finally, the phylogenies can also be imported in form of a list and in phylogenetic comparative methods this list of phylogenies is called **multiPhylo**, and we can import/export these multiPhylos in the two formats.

```{r}
# Simulate 10 phylogenies, each one with 5 species
multitree <- replicate(10, rcoal(5), simplify = FALSE)
# Store the list of trees as a multiPhylo object
class(multitree) <- "multiPhylo"
```

```{r}
# Plot a single tree from the 10
plot(multitree[[10]])
```

```{r}
par(mfrow = c(2, 2))
plot(multitree[[1]])
plot(multitree[[3]])
plot(multitree[[7]])
plot(multitree[[10]])
```

```{r}
# Exporting the phylogenies as a single Newick file. 
write.tree(phy = multitree, file = "../Data/Lab_0/multitree_example_newick.txt")
multitree_example_newick <- read.tree("../Data/Lab_0/multitree_example_newick.txt")
multitree_example_newick
```

```{r, warnings = FALSE, message = FALSE}
# Exporting the phylogenies as a single Nexus file. 
write.nexus(phy = multitree, file = "Data/Lab_0/multitree_example_nexus.nex")
multitree_example_nexus <- read.nexus("Data/Lab_0/multitree_example_nexus.nex")
multitree_example_nexus
```

:::{.callout-tip}
## The :: operator
If you know exactly which package contains the function you want to use you can reference it directly using the **::** operator. Simply place the {package name} before the operator and the name of the function after the operator to retrieve it. 

In simple words, if you just want to use a specific function of an R package and not the entire package, the **::** operator can do it for you. for example: 

multitree_example_nexus <- ape::read.nexus("Data/Lab_0/multitree_example_nexus.nex")

:::

# Gentle intro to loops

In programming one of the most important tool is the **loop** AKA **for**. Basically, a loop runs for **n** number of steps in a previously defined statement.

The basic syntax struture of a loop is:

```{r} 
#| eval: false
for (variable in vector) {
  execute defined statements
}
```

When we are writing some piece of code it is common to use the loop variable **i** to determine the number of steps. Why not other letter?, well **i** is the first letter of the word **iteration** —duh! Anyway, you can use any letter or word as a loop variable.

So, let's take a look.

```{r}
for (i in 1:10){
  cat(i, sep = '')
}
```

Notice that the number of steps is determined by the loop variable and in this example is a sequence of steps from 1 to 10, that correspond to the second element of the **for loop**, the **vector**.

You can modify the previous statement to obtain different results, for example:

```{r}
for (i in 1:10){
  cat(i, sep = '\n')
}
```

Or using a previous object:

```{r}
for (i in 5:length(ex)){
  cat(i, sep = '\n')
}
```

Or to make calculations

```{r}
for (i in 5:length(ex)){
  b2 <- b^2
  b3 <- b*2
  b4 <- b+10
}
```

To finish this short tutorial, we will welcome all of the members of the Biodiversity Science cohort 2023.

```{r}

BioSciNames <- read.csv("Data/lab_0/BioSci_2023.csv")[, 1]

```

```{r, warnings = FALSE, message = FALSE}
for (i in 1:length(BioSciNames)){ 
  
  print(paste0("Hi ", BioSciNames[i], ", welcome to the first practice of Biodiversity Science 2023!"))
  
  Sys.sleep(2) # wait two seconds before the next iteration or name
}
```

We have covered basic aspects of R, from exploring and managing objects to import/export data and basics into loops. We hope that this short tutorial can be helpful not only for the **Biodiversity Science** course but for your specific projects. Remember, practice, practice, practice!

