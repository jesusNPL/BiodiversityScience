---
title: "Introduction to Phylogenies and the Comparative Method"
description: Showing some neat features of R!
date: today # other options: now, last-modified
authors:
  - name: Jesús N. Pinto-Ledezma 
          and Jeannine Cavender-Bares 
    url: https://jesusnpl.github.io
    affiliation: Ecology, Evolution & Behavior, University of Minnesota
                Biodiversity Science - EBB (5534)
    affiliation-url: https://github.com/jesusNPL/BiodiversityScience
title-block-banner: true
#title-block-banner: "#562457"
format: 
  html: 
    embed-resources: true # save contained file.
    theme: darkly # check other themes https://quarto.org/docs/output-formats/html-themes.html
    code-fold: true
    toc: true
    number-sections: true
bibliography: lab_1_PCM.bib
link-citations: yes
csl: ../apa-single-spaced.csl
---

:::{.callout-note}
In this lab, you will learn basic tools in R for visualizing phylogenies, optimizing ancestral states for a discrete and continuous characters, testing models of character evolution, and performing phylogenetic correction of a regression model. This lab is based in part on one designed by [Luke Harmon](https://scholar.google.com/citations?hl=en&user=nsA3IsgAAAAJ&view_op=list_works) for a workshop that he and others ran at Ilha Bela, Brazil; the original can be seen [here](http://lukejharmon.github.io/ilhabela/instruction/2015/07/03/PGLS/) There are many other useful labs in comparative analysis from that [workshop](http://lukejharmon.github.io/ilhabela/) that you can peruse at your leisure. 
:::

You will need two datasets, that will be provided for you:

1. A data.frame with species traits -- **furnariides_traits.csv**

2. A phylogenetic tree -- **furnariides_tree.nex**

The clade we will work on today is the **Furnariides (Aves: Passeriformes)**, also known as the largest continental endemic radiation [@pinto-ledezma_drivers_2019]. We will use the phylogenetic tree reconstructed by Jesús. The trait data correspond to several morphological measurements of birds from **AVONET** [@tobias_avonet_2022].

# Set up your data and your working directory

You will need to have a set of R packages to do this lab. Install the following packages:

```{r}
#| eval: false
packages <- c("tidyverse", "ape", "geiger", "nlme", "phytools", "rr2") 
# Package vector names
```

:::{.callout-tip}
## Function install.packages()
You can use the function **install.packages()** to install the packages.
:::

If you don't want to install the packages one by one, you can use the next command. 
```{r}
#| eval: false
# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())

if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages], dependencies = TRUE)
}
```

This command, will, first, check if you already the packages installed, then if a package is not installed in your computer, will install it.

Load installed packages:

```{r}
library(tidyverse)
library(ape)
library(geiger)
library(nlme)
library(phytools)
library(rr2)
```

Set up a working directory. Tell R that this is the directory you will be using, and read in your data:

:::{.callout-tip}
## Function getwd()
You can use the function **getwd()** to get the current working directory.
:::

```{r}
#| eval: false
setwd("path/for/your/directory")
```

:::{.callout-tip}
## Function dir.create()
You can use the function **dir.create()** to get create a series of folders within your working directory. For example, if you run **dir.create("Output")** it will create an empty folder--named Output--within your working directory. This folder then can be used to store the results from the lab.
:::

Load the data. Instead of reading files from the computer we will pull the required data directly from the internet.

```{r}

## Trait data
furnaData <- read_csv("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2023/Lab_1/Data/furnariides_traits.csv") %>% 
  column_to_rownames("Sciname") %>%   # we are using the column "Sciname" as rownames
  drop_na(Range.Size)

## Phylogenetic data
furnaTree <- read.nexus("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2023/Lab_1/Data/furnariides_tree.nex")

```
OK. You should be ready to go.

let's inspect the data first, to do that we will use the function **"glimpse()"** of the R package **{dplyr}** 

:::{.callout-tip}
## The pipe (%>%) operator
This operator is, maybe, the most used operator from the {dplyr} package and is used to perform a sequence of operations on a data frame. In other words, the pipe operator simply feeds the results of one operation into the next operation below it.
:::

```{r}

glimpse(furnaData)
```

Let's check if our trait data contain the same species as in the phylogeny

```{r}

tmp <- name.check(phy = furnaTree, data = furnaData)
tmp
```

It indicates that the species *Philydor novaesi* is not present in the trait data, so let's drop this species from the phylogeny.

```{r}

furnaTree <- drop.tip(phy = furnaTree, tip = tmp$tree_not_data)
```

We can double check if our data match after dropping the missing species

```{r}

name.check(phy = furnaTree, data = furnaData)
```

Now it seems that we are ready to go!

# Working with trees

Let’s start by looking at the phylogeny of these birds and learning a bit about how to work with trees in R. 

*What does your tree look like?*

```{r}
#| eval: false
plot(furnaTree)
```

Whoa. That's ugly. Let's clean it up.

```{r}
#| eval: false
plot.phylo(furnaTree, no.margin = TRUE, cex = 0.5)
```

Better. You can mess around with tree plotting functions in **plot.phylo()** as much as you'd like. Try this for example:

```{r}

plot.phylo(furnaTree, type = "fan", no.margin = TRUE, cex = 0.3)
```

Pretty.

It may be useful to understand how trees are encoded in R. Typing in just the name of the tree file like this:

```{r}
#| eval: false
furnaTree
```

will give you basic information about the phylogeny: the number of tips and nodes; what the tips are called; whether the tree is rooted; and if it has branch lengths.

```{r}
#| eval: false
str(furnaTree)
```

will tell you more about tree structure. Trees consist of tips connected by edges (AKA branches)

```{r}
#| eval: false
furnaTree$tip.label
```

gives you a list of all your terminal taxa, which are by default numbered 1-n, where n is the number of taxa.

```{r} 
#| eval: false
furnaTree$Nnode
```

gives you the number of nodes. This is a fully bifurcating rooted tree, so it has 1 fewer node than the number of taxa.

```{r}
#| eval: false
furnaTree$edge
```

This tells you the beginning and ending node for all edges.

Put that all together with the following

```{r}
#| eval: false
plot.phylo(furnaTree, type = "fan", no.margin = TRUE, cex = 0.7, label.offset = 0.1)
nodelabels(cex = 0.5)
tiplabels(cex = 0.5)
```

There are many ways to manipulate trees in R using **{Ape}**, **{Phytools}**, and other packages. This just gives you a bare-bones introduction.

# Working with a data matrix and testing hypotheses in a phylogenetically informed way

Let's ask some questions using the trait data that were measured for these birds. First, explore the data in the "furnaData" matrix. Here are some options for visualizing data matrices:

```{r}
#| eval: false
furnaData %>% 
  head() # this will show you the first few rows of your data matrix and its header

furnaData %>% 
  dimnames() # this will show you the row and column headers for your matrix

furnaData %>% 
  View() # this will let you visualize the entire matrix
```
After looking at the data, please answer the next questions

*What variables were measured for each of these species of Furnariides? How many species of Furnariides were used?* 

*Is that the same number that were in your phylogeny?*

**Hand-wing index** is one of your variables. Let's isolate it so we can work with it easily:

```{r}

hwi <- furnaData[, "Hand-Wing.Index"]
names(hwi) <- rownames(furnaData) 
# data vectors have to be labelled with tip names for the associated tree. 
# This is how to do that.
```


:::{.callout-tip}
## Exploring the data
It is good practice to check the distribution of your data before doing downstream analysis. 
:::

```{r}
hist(hwi)
```


In lecture, Brie talked about one model of character evolution, called a **Brownian Motion** model. This model assumes that a trait evolves from a starting state (**z0**) according to a random walk with the variance specified by the rate parameter $\sigma^{2}$ (**sigma-squared**). In short, Brownian motion describes a process in which tip states are modeled under the assumption of a multivariate normal distribution. On a phylogeny, the multivariate mean of tip states is equal to the root state estimate, and variance accumulates linearly through time.

*What does Brownian Motion evolution of hand-wing index in Furnariides look like?*

```{r}
#| eval: false
brownianModel <- fitContinuous(furnaTree, hwi)
brownianModel # this will show you the fit statistics and parameter values
```

Here, you can see the estimates for ancestral state (z0), and the rate parameter ($\sigma^{2}$), as well as some measures of model fit. The fit of the model is determined using maximum likelihood, and expressed as a log likelihood **(lnL)**. The higher the **lnL**, the more probable the data given the model. However, when comparing different models, we can't use the **lnL**, because it does not account for the difference in the number of parameters among models. Models with more parameters will always fit better, but do they fit significantly better? For example an OU model has 4 parameters (alpha [$\alpha$], theta [$\theta$], z0, and sigma-squared [$\sigma^{2}$]), so it should fit better than a BM model, which includes only z0 and sigsq. To account for this, statisticians have developed another measure of fit called the AIC (Akaike Information Criterion): **AIC = (2xN)-2xlnL**, where **N** is the number of parameters. This penalizes the likelihood score for adding parameters. When selecting among a set of models, the one with the lowest AIC is preferred. We will use this information later on in this lab.

In addition to assessing model fit, we can use the Brownian Motion model to reconstruct ancestral states of a character on a tree. To visualize what BM evolution of this trait looks like on a tree. The *contMap()* command in phytools estimates ancestral states and plots them on a tree.

```{r}
#| eval: false
contMap(furnaTree, hwi, fsize = 0.5, lwd = 3)
```

*Describe the evolution of Hand-wing index on this tree. How many times have exteremely high and extremely low Hand-wing index evolved on this tree?* 

*What does this say about our ability to test hypotheses about the evolution of Hand-wing index?*

Let’s go ahead and test some hypotheses. **Range Size** is another trait in your data matrix. Let’s assess whether there is a correlation between HWI and body mass? We will extract the column "Range Size" from the datamatrix and assign it species names, just as we did for "HWI" above.

```{r}
#| eval: false
rangeSize <- furnaData[, "Range.Size"]
names(rangeSize) <- rownames(furnaData)
```

Let’s look at a plot of range size as a function of Hand-wing index.

```{r}
#| eval: false
furnaData %>% 
  drop_na(Range.Size) %>% 
  ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) + 
  geom_point(alpha = 0.5, color = "darkgray") + 
  labs(x = "Hand-Wing Index", y = "log(Range Size)")

```

Hm. looks promising. *How would you describe the relationship between these two variables?*

*Why did we log scale range size?*

Let's be more quantitative in describing that relationship with a linear model.

```{r}
#| eval: false
lm_hwi_rangesize <- lm(log(rangeSize) ~ hwi)
summary(lm_hwi_rangesize)
```

```{r}

furnaData %>% 
  drop_na(Range.Size) %>% 
  ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) + 
  geom_point(alpha = 0.5, color = "darkgray") + 
  labs(x = "Hand-Wing Index", y = "log(Range Size)") + 
  geom_smooth(method = "lm")

```

The coefficients table from the *summary()* command shows the slope and intercept for the linear model describing **range size** as a function of **Hand-wing index**. Each line shows the estimated coefficient (Estimate), the standard error (Std. Error) of that estimate, as well as a t-statistic and associated p-value, testing whether those parameters are equal to 0. The Multiple R-squared is an estimate of how much variance in the response variable can be explained by the predictor variable.

*Write the linear model for this relationship. Are the parameters significantly different from 0?* 

*What is the R^2 value for this data?* 

*How do you feel about that?*

## Phylogenetic regression (PGLS)

Nice. But. We have not considered the fact that these birds are related to each other, in fact, all this birds are monophyletic--i.e., the clade includes an ancestral taxon and all of its descendants. As such, they may share their hand-wing index and range size simply due to the fact that their ancestors had large HWI and range size or the reverse. In other words, we need to account for non-independence of residuals due to phylogeny. One way to do that is to use phylogenetic-generalized-least-squares regression (PGLS).

```{r}
#| eval: false
pglsModel <- gls(log(rangeSize) ~ hwi, 
                 correlation = corBrownian(phy = furnaTree, form=~names(rangeSize)), 
                 method = "ML")
```

Let's break this command down. This command infers a linear model for Range Size as a function of HWI (gls(rangeSize ~ hwi), but it specifies existing correlation structure in the data (correlation =) as the covariance of these traits assuming a Brownian motion model (corBrowinan()) based on the Furnariides tree (phy = furnaTree) and a correctly ordered list of taxon names (form=~names(rangeSize)). The model is fit using maximum likelihood (method = "ML"). To see the results:

```{r}
#| eval: false
summary(pglsModel)
coef(pglsModel)
R2(pglsModel)
```

```{r}
#| eval: false
furnaData %>% 
  drop_na(Range.Size) %>% 
  ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) + 
  geom_point(alpha = 0.5, color = "darkgray") + 
  labs(x = "Hand-Wing Index", y = "log(Range Size)") + 
  #geom_smooth(method = "lm") + 
  geom_abline(intercept = coef(pglsModel)[1], slope = coef(pglsModel)[2], 
              color = "red", linewidth = 1.5)

# will plot the pgls regression line on your biplot.
```

*Write the linear model for this relationship. Are the parameters significantly different from 0?*

*What is the R^2 value for this data? (use the likelihood-based R^2 value)* 

*How do you feel about that?* 

*Compare results from the pgls analysis with those that you got from the regular linear model you ran earlier.*

# Model Fitting

Brownian Motion is only one model of evolution for a continuous variable. Another model is the **Ornstein-Uhlenbeck (OU)** model, which allows the trait mean to evolve towards a new state (theta), with a selective force (alpha). These two new parameters, plus the starting state (z0) and the rate of evolution (sigsq) parameters from the BM model, make for a 4-parameter model. The **Early Burst (EB)** model allows the rate of evolution to change across the tree, where the early rate of evolution is high and declines over time (presumably as niches are filled during an adaptive radiation. The rate of evolution changes exponentially over time and is specified under the model r[t] = r[0] x exp(a x t), where r[0] is the initial rate, a is the rate change parameter, and t is time. The maximum bound is set to -0.000001, representing a decelerating rate of evolution. The minimum bound is set to $log(10^{-5})$/depth of the tree.

Let’s evaluate the relative fit of these three models to the Hand-wing index trait.

## Brownian Motion (BM)
```{r}
#| eval: false
brownianModel <- fitContinuous(furnaTree, hwi)
```

## Ornstein-Uhlenbeck (OU)
```{r}
#| eval: false
OUModel <- fitContinuous(furnaTree, hwi, model = "OU")
```

## Early Burst (EB)
```{r}
#| eval: false
EBModel <- fitContinuous(furnaTree, hwi, model = "EB")
```

And recover the parameter values and fit estimates.

```{r}
#| eval: false
brownianModel
OUModel
EBModel
```

Compare all models and select the best fitting model.

```{r}
#| eval: false
aicw(c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc))
```


*Make a table with the AIC and lnL values for each model. Which model provides the best fit for Habd-wing index?* 

*Now, add the results for a model fitting analysis of the Hostility trait to this table.*

So, we were wrong. An OU model fits HWI better (and you should be able to explain how we know that). Unfortunately, a PGLS analysis with an OU model specified is currently computationally difficult. The best we can do is report the results from our model fitting analysis, and realize that the parameters from BM might not be the best fit.

However, we can still test our hypothesis that species with large HWI also present large range size, and account for phylogeny when we do. First, we should compare the uncorrected linear model of range size as a function of HWI vs the PGLS that uses the covariance structure of the residuals under a Brownian Motion model.

```{r}
#| eval: false
furnaData %>% 
  drop_na(Range.Size) %>% 
  ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) + 
  geom_point(alpha = 0.5, color = "darkgray") + 
  labs(x = "Hand-Wing Index", y = "log(Range Size)") + 
  geom_smooth(method = "lm") + 
  geom_abline(intercept = coef(pglsModel)[1], slope = coef(pglsModel)[2], 
              color = "red", linewidth = 1.5)

```

You might want to know if these regressions really differ in their ability to predict range size from HWI. Asked in another way, are the slopes from these two regressions significantly different from each other? You need to know that a 95% confidence interval for the slope parameter is b (the slope) plus/minus 1.96 standard errors (this is derived from a normal distribution). To calculate your 95% confidence intervals:

```{r}
#| eval: false
rshwi.sum <- summary(lm_hwi_rangesize)

#for the uncorrected linear model
rshwi.sum$coef[2, 1] + c(-1.96, 1.96)*rshwi.sum$coef[2, 2]

#for Brownian Motion, the 95% CI
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])

```

*Did phylogenetic correction make a difference in this case?* 

*What do you conclude about the evolution of range size as a function of hand-wing index?*

# Phylogenetic signal 

Phylogenetic signal is the tendency of related species to resemble each other more than species drawn at random from the same tree.

## Blomberg's K

Blomberg’s K compares the variance of **PICs** to what we would expect under a Brownian motion (BM) model of evolution. **K = 1** means that close relatives resemble each other as much as we should expect under BM. **K < 1** that there is less **phylogenetic signal** than expected under BM and that **K > 1** means that there is more. In addition, a significant p-value returned from a randomization test tells us that the phylogenetic signal is significant, in other words, close relatives are more similar than random pairs of taxa in the dataset.

```{r}
#| eval: false
K_hwi <- phylosig(tree = furnaTree, # Phylogeny
                  x = hwi, # trait
                  method = "K", # method
                  test = TRUE)
print(K_hwi)
plot(K_hwi)
```

## Pagel's Lambda

Pagel’s $\lambda$ is a tree transformation that stretches the tip branches relative to internal branches, making the tree more and more like a complete polytomy of a star phylogeny. If $\lambda = 0$ there is no phylogenetic signal, while $\lambda = 1$ correspond to BM and $0 < \lambda < 1$ in between.

```{r}
#| eval: false
LB_hwi <- phylosig(tree = furnaTree, 
                  x = hwi, 
                  method = "lambda", 
                  test = TRUE)
print(LB_hwi)
plot(LB_hwi)
```
*Describe the results of phylogenetic signal. Does Hand-wing index present phylogenetic signal?*

# Discrete Character Mapping

So far, we have been dealing with continuous characters, those that take values along some continuum. Things like height, weight, length, temperature, humidity, etc. are continuous variables. There is another type of variable called a discrete variable, that takes, well, discrete values. Color (e.g. red, blue, green); Locomotory type (e.g. scansoial, terrestrial, fossorial) are examples of discrete variables.

Look at the data in the furnaData matrix. *Which of these variables are discrete and which are continuous?*

In your data matrix, **Habitat** has been coded for each of these species. Let’s examine some biogeography for these birds by reconstructing the ancestral habitat (i.e. habitat of origin) and dispersal history. First, isolate your variable.

```{r}
#| eval: false
habitat <- furnaData$Habitat_recode
names(habitat) <- rownames(furnaData)

table(habitat)
```

We can simultaneously fit a model of discrete character evolution and create a set of plausible character histories using a method called stochastic character mapping or simply **SIMMAP**:

```{r}
#| eval: false
habitat_anc <- make.simmap(furnaTree, habitat, model = "SYM", nsim = 100)

```

This analysis results in a "Q" matrix showing the relative probabilities of change from state to state. For this character, this would represent dispersal events between habitats. The higher the value, the higher the probability of that type of change.

*Which pair of islands shows the highest probability of interchange?* 

*Which pair shows the least?* 

*Does this make sense geographically?*

Now, you can plot a random simulation of change in this character, that is based on the values inferred above.

```{r}
#| eval: false
plotSimmap(habitat_anc[[1]], fsize = 0.5) # this plots the first of 100 simulations
```

*How many transitions are there between black and red?* 

*Are there any reversals?* 

*Are there any branches with more than one change?* 

*Using the command above, but changing the index from 1 to other values, look at a number of reconstructions. How much variation do you see?*


We can summarize these simulations and estimate the relative probability of each island as an ancestor for each node on our tree:

```{r}
#| eval: false
habitat_summary <- summary(habitat_anc)

habitat_summary # print the results
```

Plot the resulting reconstruction

```{r}
#| eval: false
plot(habitat_summary, cex = c(0.5, 0.2), fsize = 0.5, offset = 90)
legend("bottomleft", fill = c("black", "red", "green"), 
       legend = c("Forest", "Savanna", "Transition"))
```

We can also use the plot function **"plotSimmap"** to change the colors of the habitats

```{r}
#| eval: false
cols <- setNames(c("darkgreen", "khaki", "gray"), 
                 c("Forest", "Savanna", "Transition"))
```

```{r}
#| eval: false
plotSimmap(habitat_anc[[1]], cols)
add.simmap.legend(colors = cols, prompt = FALSE, x = 0, y = -0.5,
    vertical = FALSE)
```

*Where did Furnariides likely originate?* 

*How many transitions from Forest to Savanna?* 

*Are there any reversals?* 

*Does a Savanna ancestor ever move back to Forest?* 

