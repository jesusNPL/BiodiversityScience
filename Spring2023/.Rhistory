library(adehabitatLT)
# GIS packages
library(sf)
library(sp)
# Load functions for later
source("https://raw.githubusercontent.com/eco4cast/Statistical-Methods-Seminar-Series/main/michelot_movement/code/utility_functions.R")
# Load data from Movebank URL
URL <- paste0("https://www.datarepository.movebank.org/bitstream/handle/10255/",
"move.981/ThermochronTracking%20Elephants%20Kruger%202007.csv")
raw <- read.csv(url(URL))
raw <- read.csv(url(URL))
install.packages("brms", type = "source")
package_version(brms)
package_version("brms")
?package_version
install.packages("rstan", type = "source")
# install from my R-universe repository
install.packages("aniMotum", repos = "https://ianjonsen.r-universe.dev")
library(brms)
?brm
prior1 <- prior(normal(0,10), class = b) +
prior(cauchy(0,2), class = sd)
fit1 <- brm(count ~ zAge + zBase * Trt + (1|patient),
data = epilepsy, family = poisson(), prior = prior1, backend = "cmdstanr")
fit1
install.packages("tidybayes")
install.packages("devtools")
install.packages(c("bayesplot", "bayestestR", "BiocManager"))
install.packages(c("arm", "bRacatus", "data.table", "deSolve", "DT", "dtplyr", "fields", "fundiversity", "furrr", "future", "future.apply"))
install.packages(c("vegan", "vroom", "whisker", "workflows", "WorldFlora"))
install.packages(c("cluster", "foreign", "MASS", "Matrix", "mgcv", "nlme", "nnet"), lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages("tidymodels")
install.packages("caret")
install.packages(c("bnclassify", "brew", "emmeans", "ENMeval", "ggbeeswarm", "ggbreak", "ggdensity", "ggdist", "ggfun", "gghalves", "ggmap", "ggnewscale", "ggpubr", "ggrepel", "ggridges", "ggsignif", "glmnet", "hdf5r", "HDInterval", "Hmisc", "iNEXT", "knitr", "markdown", "MatrixModels", "matrixStats"))
install.packages("momentuHMM", dependencies = TRUE)
install.packages(c("distributional", "doRNG", "dotCall64", "hypervolume", "lpSolve", "lubridate", "maptools", "mclust", "neonUtilities", "pbapply", "performance", "phangorn", "phytools", "posterior", "qgraph", "rasterVis"))
install.packages(c("quantreg", "R.cache", "R.utils", "ragg", "rbibutils", "RCurl"))
install.packages(c("readr", "readxl", "recipes", "renv", "repr", "reprex", "rgbif", "rgeos", "rgl", "rlas", "rmarkdown", "rncl", "RNeXML", "rotl", "RPANDA", "rredlist"))
install.packages(c("RcppArmadillo", "RcppGSL", "RcppParallel", "RcppTOML"))
install.packages(c("spatialreg", "spatstat", "spatstat.data", "spatstat.geom", "spatstat.linnet", "spatstat.random", "spatstat.sparse", "spatstat.utils", "spData", "spdep", "spectrolab"))
install.packages("boot", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages(c("gower", "gstat", "gtools", "latticeExtra", "lidR", "lme4", "paleotree", "palmerpenguins", "parameters", "plotly", "polyclip", "PresenceAbsence", "rsample", "rsconnect", "rstudioapi", "rversions", "sparklyr", "spOccupancy", "stars"))
install.packages(c("gower", "gstat", "gtools", "latticeExtra", "lidR", "lme4", "paleotree", "palmerpenguins", "parameters", "plotly", "polyclip", "PresenceAbsence", "rsample", "rsconnect", "rstudioapi", "rversions", "sparklyr", "spOccupancy", "stars"))
install.packages(c("scatterplot3d", "segmented", "textrecipes", "tidyquant", "tidytext", "tidytree", "timeDate"))
install.packages("stars")
install.packages(c("ps", "shiny", "skimr", "spam", "timeSeries", "topicmodels", "tune", "V8"))
install.packages("rpart", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
# Plotting package
library(tidyverse)
theme_set(theme_bw())
# Movement modelling packages
library(momentuHMM)
# install from my R-universe repository
#install.packages("aniMotum", repos = "https://ianjonsen.r-universe.dev")
library(aniMotum)
library(adehabitatLT)
# GIS packages
library(sf)
library(sp)
# Load functions for later
source("https://raw.githubusercontent.com/eco4cast/Statistical-Methods-Seminar-Series/main/michelot_movement/code/utility_functions.R")
# Load data from Movebank URL
URL <- paste0("https://www.datarepository.movebank.org/bitstream/handle/10255/",
"move.981/ThermochronTracking%20Elephants%20Kruger%202007.csv")
raw <- read.csv(url(URL))
revdep_check()
?momentuHMM::fitHMM
?aniMotum::fit_ssm
# Plotting package
library(tidyverse)
theme_set(theme_bw())
# Movement modelling packages
library(momentuHMM)
# install from my R-universe repository
#install.packages("aniMotum", repos = "https://ianjonsen.r-universe.dev")
library(aniMotum)
library(adehabitatLT)
# GIS packages
library(sf)
library(sp)
# Load functions for later
source("https://raw.githubusercontent.com/eco4cast/Statistical-Methods-Seminar-Series/main/michelot_movement/code/utility_functions.R")
raw <- read.csv("Downloads/ThermochronTracking Elephants Kruger 2007.csv")
head(raw)
# Keep relevant columns: ID, time, longitude, latitude, temperature
data_all <- raw[, c(9, 3, 4, 5, 6)]
colnames(data_all) <- c("ID", "time", "lon", "lat", "temp")
data_all$time <- as.POSIXct(data_all$time, format = "%Y-%m-%d %H:%M:%S", tz = "GMT")
# Just keep 2000 observations to save time with model fitting
data <- data_all[c(which(data_all$ID == unique(data_all$ID)[5])[1:1000],
which(data_all$ID == unique(data_all$ID)[6])[1:1000]),]
head(data)
# Plot latitude vs longitude (Mercator projection)
ggplot(data, aes(lon, lat, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_map("mercator")
# Longitude vs time
ggplot(data, aes(time, lon, col = ID)) +
geom_point(size = 0.5) + geom_path()
# Latitude vs time
ggplot(data, aes(time, lat, col = ID)) +
geom_point(size = 0.5) + geom_path()
# Project to UTM
llcoord <- st_as_sf(data[, c("lon", "lat")], coords = c("lon", "lat"),
crs = CRS("+proj=longlat +datum=WGS84"))
utmcoord <- st_transform(llcoord, crs = CRS("+proj=utm +zone=35 +datum=WGS84"))
# Add Easting-Northing to data (in km)
data[, c("x", "y")] <- st_coordinates(utmcoord)/1000
# Plot Northing vs Easting
ggplot(data, aes(x, y, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Table of time intervals in data
plot(table(diff(data$time)), xlim = c(0, 300),
xlab = "time interval (min)", ylab = "count")
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = data, max_gap = 2*60, shortest_track = 24*60)
ggplot(data_split, aes(x, y, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Create adehabitat trajectory padded with NAs
data_ade <- setNA(ltraj = as.ltraj(xy = data_split[, c("x", "y")],
date = data_split$time,
id = data_split$ID),
date.ref = data_split$time[1],
dt = 30, tol = 5, units = "min")
# Transform back to dataframe
data_na <- ld(data_ade)[, c("id", "x", "y", "date")]
colnames(data_na) <- c("ID", "x", "y", "time")
# Add temperatures for non-missing locations
data_na$temp <- NA
data_na$temp[which(!is.na(data_na$x))] <- data_split$temp
head(data_na, 10)
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- prepData(data_na, type = "UTM", covNames = "temp")
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- momentuHMM::prepData(data_na, type = "UTM", covNames = "temp")
# Observation distributions (step lengths and turning angles)
dist <- list(step = "gamma", angle = "vm")
# Initial parameters
# (step mean 1, step mean 2, step SD 1, step SD 2) and (angle concentration 1, angle concentration 2)
Par0_2s <- list(step = c(0.05, 0.2, 0.05, 0.2), angle = c(0.1, 3))
?momentuHMM::prepData
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- momentuHMM::prepData(data_na, type = "UTM", covNames = "temp")
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- momentuHMM:::prepData(data_na, type = "UTM", covNames = "temp")
install.packages("multimark")
# Movement modelling packages
library(momentuHMM)
remotes::install_github("bmcclintock/momentuHMM")
# Plotting package
library(tidyverse)
theme_set(theme_bw())
# Movement modelling packages
library(momentuHMM)
# install from my R-universe repository
#install.packages("aniMotum", repos = "https://ianjonsen.r-universe.dev")
library(aniMotum)
library(adehabitatLT)
# GIS packages
library(sf)
library(sp)
# Load functions for later
source("https://raw.githubusercontent.com/eco4cast/Statistical-Methods-Seminar-Series/main/michelot_movement/code/utility_functions.R")
install.packages("Brobdingnag")
# Movement modelling packages
library(momentuHMM)
# Plotting package
library(tidyverse)
theme_set(theme_bw())
# Movement modelling packages
library(momentuHMM)
# install from my R-universe repository
#install.packages("aniMotum", repos = "https://ianjonsen.r-universe.dev")
library(aniMotum)
library(adehabitatLT)
# GIS packages
library(sf)
library(sp)
# Load functions for later
source("https://raw.githubusercontent.com/eco4cast/Statistical-Methods-Seminar-Series/main/michelot_movement/code/utility_functions.R")
raw <- read.csv("Downloads/ThermochronTracking Elephants Kruger 2007.csv")
# Keep relevant columns: ID, time, longitude, latitude, temperature
data_all <- raw[, c(9, 3, 4, 5, 6)]
colnames(data_all) <- c("ID", "time", "lon", "lat", "temp")
data_all$time <- as.POSIXct(data_all$time, format = "%Y-%m-%d %H:%M:%S", tz = "GMT")
# Just keep 2000 observations to save time with model fitting
data <- data_all[c(which(data_all$ID == unique(data_all$ID)[5])[1:1000],
which(data_all$ID == unique(data_all$ID)[6])[1:1000]),]
head(data)
# Plot latitude vs longitude (Mercator projection)
ggplot(data, aes(lon, lat, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_map("mercator")
# Longitude vs time
ggplot(data, aes(time, lon, col = ID)) +
geom_point(size = 0.5) + geom_path()
# Latitude vs time
ggplot(data, aes(time, lat, col = ID)) +
geom_point(size = 0.5) + geom_path()
# Project to UTM
llcoord <- st_as_sf(data[, c("lon", "lat")], coords = c("lon", "lat"),
crs = CRS("+proj=longlat +datum=WGS84"))
utmcoord <- st_transform(llcoord, crs = CRS("+proj=utm +zone=35 +datum=WGS84"))
# Add Easting-Northing to data (in km)
data[, c("x", "y")] <- st_coordinates(utmcoord)/1000
# Plot Northing vs Easting
ggplot(data, aes(x, y, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Table of time intervals in data
plot(table(diff(data$time)), xlim = c(0, 300),
xlab = "time interval (min)", ylab = "count")
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = data, max_gap = 2*60, shortest_track = 24*60)
ggplot(data_split, aes(x, y, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Create adehabitat trajectory padded with NAs
data_ade <- setNA(ltraj = as.ltraj(xy = data_split[, c("x", "y")],
date = data_split$time,
id = data_split$ID),
date.ref = data_split$time[1],
dt = 30, tol = 5, units = "min")
# Transform back to dataframe
data_na <- ld(data_ade)[, c("id", "x", "y", "date")]
colnames(data_na) <- c("ID", "x", "y", "time")
# Add temperatures for non-missing locations
data_na$temp <- NA
data_na$temp[which(!is.na(data_na$x))] <- data_split$temp
head(data_na, 10)
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- momentuHMM::prepData(data_na, type = "UTM", covNames = "temp")
head(data_hmm1, 10)
# Observation distributions (step lengths and turning angles)
dist <- list(step = "gamma", angle = "vm")
# Initial parameters
# (step mean 1, step mean 2, step SD 1, step SD 2) and (angle concentration 1, angle concentration 2)
Par0_2s <- list(step = c(0.05, 0.2, 0.05, 0.2), angle = c(0.1, 3))
# Fit a 2-state HMM
hmm1 <- momentuHMM::fitHMM(data_hmm1, nbStates = 2, dist = dist, Par0 = Par0_2s)
# Print parameter estimates
hmm1
# Plot estimated distributions and state-coloured tracks
plot(hmm1, breaks = 25, ask = FALSE)
# Initial parameters for 3-state model
Par0_3s <- list(step = c(0.02, 0.1, 0.3, 0.02, 0.1, 0.3),
angle = c(0.01, 0.1, 3))
# Fit 3-state HMM
hmm2 <- momentuHMM::fitHMM(data_hmm1, nbStates = 3, dist = dist, Par0 = Par0_3s)
hmm2
plot(hmm2, breaks = 25, ask = FALSE)
# Get most likely sequence of states (Viterbi algorithm)
head(viterbi(hmm2))
# Save most likely state sequences from 2-state and 3-state models
data_hmm1$state_2st <- factor(viterbi(hmm1))
data_hmm1$state_3st <- factor(viterbi(hmm2))
# Plot tracks, coloured by states
ggplot(data_hmm1, aes(x, y, col = state_2st, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
ggplot(data_hmm1, aes(x, y, col = state_3st, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Fit 2-state HMM with temperature covariate (linear or quadratic effect)
hmm3 <- momentuHMM::fitHMM(data_hmm1, nbStates = 2, dist = dist,
Par0 = Par0_2s, formula = ~temp)
hmm4 <- momentuHMM::fitHMM(data_hmm1, nbStates = 2, dist = dist,
Par0 = Par0_2s, formula = ~temp+I(temp^2))
# Compare models using AIC
AIC(hmm3, hmm4)
# Plot estimated distributions and transition probabilities as functions of temperature
plot(hmm3, plotTracks = FALSE, ask = FALSE, plotCI = TRUE)
# Plot stationary state probabilities as functions of temperature
plotStationary(hmm3, plotCI = TRUE)
# Plot pseudo-residuals for 2-state and 3-state models
plotPR(hmm1)
plotPR(hmm2)
# Change data to format expected by foieGras
data_foieGras <- data_split[,c("ID", "time", "lon", "lat")]
colnames(data_foieGras)[1:2] <- c("id", "date")
# Add column for location quality class (G for "GPS")
data_foieGras$lc <- "G"
# Change order of columns as expected by foieGras
data_foieGras <- data_foieGras[,c(1, 2, 5, 3, 4)]
##### aniMotum #####
# Fit state-space model to predict regular locations on 0.5h grid
ssm <- fit_ssm(d = data_foieGras, time.step = 0.5)
##### aniMotum #####
# Fit state-space model to predict regular locations on 0.5h grid
ssm <- aniMotum::fit_ssm(d = data_foieGras, time.step = 0.5)
# Predict locations on 30-min grid using crawl (through momentuHMM wrapper)
crw_out <- crawlWrap(obsData = data_split, timeStep = "30 min",
Time.name = "time", coord = c("x", "y"))
data_hmm3 <- prepData(data = crw_out)
# Fit 2-state HMM to regularised data
hmm5 <- fitHMM(data_hmm3, nbStates = 2, dist = dist, Par0 = Par0_2s)
# Fit HMM using multiple imputation
hmm6 <- MIfitHMM(miData = crw_out, nSims = 10, ncores = 3, nbStates = 2,
dist = dist, Par0 = Par0_2s)
plot(hmm6)
library(brms)
install.packages("terra")
install.packages("terra")
install.packages("sf", configure.args = "--with-proj-lib=/usr/local/lib/")
install.packages("sf", configure.args = "--with-proj-lib=/usr/local/lib/")
install.packages("terra")
install.packages("rgdal", configure.args = c("--with-proj-lib=/usr/local/lib/", "--with-proj-include=/usr/local/include/"))
library(terra)
install.packages("sdm", dependencies = TRUE)
sdm::installAll()
sdm::installAll()
devtools::install_git("https://github.com/carlos-alberto-silva/rGEDI", dependencies = TRUE)
devtools::install_git("https://github.com/carlos-alberto-silva/rGEDI", dependencies = TRUE)
install.packages("rstan")
install.packages("rstan", type = "source")
remotes::install_git("https://github.com/carlos-alberto-silva/rGEDI")
gc()
remotes::install_github("carlos-alberto-silva/rGEDI")
# libraries we need
libs <- c("elevatr", "terra", "tidyverse",
"sf", "giscoR", "marmap")
# load libraries
invisible(lapply(libs, library, character.only = T))
crsLONGLAT <- "+proj=longlat +datum=WGS84 +no_defs"
get_sf <- function(country_sf, country_transformed) {
country_sf <- giscoR::gisco_get_countries(
year = "2016",
epsg = "4326",
resolution = "10",
country = c("Ecuador", "Peru", "Brazil", "Colombia"))
country_transformed <- st_transform(country_sf, crs = crsLONGLAT)
return(country_transformed)
}
country_transformed <- get_sf()
get_elevation_data <- function(country_elevation, country_elevation_df) {
country_elevation <- get_elev_raster(
locations = country_transformed,
z = 5,
clip = "locations")
country_elevation_df <- as.data.frame(country_elevation, xy = T) %>%
na.omit()
colnames(country_elevation_df)[3] <- "elevation"
return(country_elevation_df)
}
country_elevation_df <- get_elevation_data()
head(country_elevation_df)
country_elevation_df <- country_elevation_df[country_elevation_df$x > -85,]
country_elevation_df <- country_elevation_df[country_elevation_df$x < -70,]
country_elevation_df <- country_elevation_df[country_elevation_df$y > -15,]
country_elevation_df <- country_elevation_df[country_elevation_df$y < 5,]
country_elevation_df <- country_elevation_df[country_elevation_df$elevation > 0,]
theme_set(theme_classic())
country_map <- ggplot(country_elevation_df, aes(x = x, y = y, fill = elevation)) +
geom_tile() +
borders("world", xlim = c(-85, -70), ylim = c(-15, 5))+
scale_fill_gradient("elevation (m)", low = "gray80", high = "gray28") +
coord_sf(crs = crsLONGLAT)+
theme_void()
country_map
ggplot(country_elevation_df, aes(x = x, y = y, fill = elevation)) +
geom_tile() +
scale_fill_gradient("elevation (m)", low = "gray80", high = "gray28") +
coord_sf(crs = crsLONGLAT)+
theme_void()
ggplot(country_elevation_df, aes(x = x, y = y, fill = elevation)) +
geom_tile() +
scale_fill_gradient("elevation (m)", low = "gray80", high = "gray28") +
coord_sf(crs = crsLONGLAT) +
theme_void()
dev.off()
gc()
?get_elev_raster
?giscoR::gisco_get_countries
?get_elev_point
load("~/Dropbox/FURNARIIDES/Furnariides_phylogeny/ClaDS/ClaDS_furnariides_new.RData")
library(RPANDA)
?ClaDS0_example
CladsOutput$tree
MAPS = getMAPS_ClaDS0(CladsOutput$tree,
CladsOutput$chains,
thin = 10)
data(ClaDS0_example)
ClaDS0_example$speciation_rates
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:4)
ClaDS0_example$speciation_rates
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:4)
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:4)
dev.off()
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:4)
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:2)
plot_ClaDS0_chains(CladsOutput$chains, param = 1:2)
plot_ClaDS0_chains(CladsOutput$chains[[1]], param = 1:2)
plot_ClaDS0_chains(CladsOutput$chains[[1]][[1]], param = 1:2)
# extract the Maximum A Posteriori for each of the parameters
MAPS = getMAPS_ClaDS0(ClaDS0_example$tree,
ClaDS0_example$Cl0_chains,
thin = 10)
MAPS
# plot the simulated (on the left) and inferred speciation rates (on the right)
# on the same color scale
plot_ClaDS_phylo(ClaDS0_example$tree,
ClaDS0_example$speciation_rates,
MAPS[-(1:3)])
ClaDS0_example$Cl0_chains
head(ClaDS0_example$Cl0_chains)
class(ClaDS0_example$Cl0_chains)
class(ClaDS0_example$Cl0_chains[[1]])
(CladsOutput$chains[[1]])
class(CladsOutput$chains[[1]])
class(CladsOutput$chains[[1]][[1]])
class(CladsOutput$chains[[1]][[100]])
CladsOutput$chains[[1]][[100]]
hist(CladsOutput$chains[[1]][[100]])
hist(CladsOutput$chains[[2]][[100]])
hist(CladsOutput$chains[[3]][[100]])
hist(CladsOutput$chains[[4]][[100]])
class(ClaDS0_example$Cl0_chains[[2]])
class(ClaDS0_example$Cl0_chains[[3]])
class(ClaDS0_example$Cl0_chains[[4]])
class(ClaDS0_example$Cl0_chains[[3]])
ClaDS0_example$Cl0_chains[[3]]
install.packages("itsdm")
library(itsdm, quietly = TRUE)
library(tidyverse)
library(stars)
library(rnaturalearth)
# Bioclimatic variables
data("mainland_africa")
force(mainland_africa)
bios <- worldclim2(var = 'bio',
bry = mainland_africa,
path = "Donwloads",
nm_mark = 'africa') %>%
st_normalize()
?worldclim2
bios <- worldclim2(var = 'bio',
bry = mainland_africa,
path = "Downloads/",
nm_mark = 'africa') %>%
st_normalize()
bios <- worldclim2(var = 'bio',
bry = mainland_africa,
#path = "Downloads/",
nm_mark = 'africa') %>%
st_normalize()
install.packages("terra", type = "source")
install.packages("terra", type = "source")
setwd("Documents/GitHub/BiodiversityScience/Spring2023/")
paste0(getwd(), "/Data/")
data_dir <- paste0(getwd(), "/Data/")
url <- "https://www.dropbox.com/s/1wb2k8kjiltq90d/Archive.zip?dl=0"
download.file(url = url,
destfile = file.path("Archive.zip"),
method = "auto",
cacheOK = FALSE)
file.path("Data/Archive.zip")
download.file(url = url,
destfile = file.path("Data/Archive.zip"),
method = "auto",
cacheOK = FALSE)
download.file(url = url,
destfile = file.path("Data/Archive.zip"),
method = "curl",
cacheOK = FALSE)
unzip(zipfile = "Data/Archive.zip", exdir = ".")
url <- "https://www.dropbox.com/s/1wb2k8kjiltq90d/Archive.zip?dl=0"
download.file(url = url,
destfile = file.path("Data/"),
method = "curl",
cacheOK = FALSE)
download.file(url = url,
destfile = data_dir)
tempfile()
temp <- tempfile()
temp
download.file("http://www.newcl.org/data/zipfiles/a1.zip", temp)
data <- read.table(unz(temp, "a1.dat"))
unlink(temp)
temp
download.file("http://www.newcl.org/data/zipfiles/a1.zip", temp)
download.file(url = url,
destfile = temp)
unzip(temp)
temp
urls <- "https://www.dropbox.com/s/1wb2k8kjiltq90d/Archive.zip?dl=0"
tempfile()
data <- read.table(unz(temp, "Archive/anolisDataAppended.csv"))
data <- read.csv(unz(temp, "Archive/anolisDataAppended.csv"))
data <- read.csv(unz(temp, "anolisDataAppended.csv"))
unz("Data/Archive.zip")
unz("Data/Archive/anolisDataAppended.csv")
anoleData <- read.csv("Data/anolisDataAppended.csv", row.names = 1)
read.csv("Data/anolisDataAppended.csv", row.names = 1)
anoleData <- read.csv("Data/anolisDataAppended.csv", row.names = 1)
anoleTree <- read.tree("Data/anolis.phy")
library(ape)
anoleTree <- read.tree("Data/anolis.phy")
plot(anoleTree)
getwd()
library(ape)
library(geiger)
library(nlme)
library(phytools)
library(rr2)
#| eval: false
setwd("path/for/your/directory")
#| eval: false
setwd("Your path or directory")
anoleData <- read.csv("Data/anolisDataAppended.csv", row.names = 1)
anoleTree <- read.tree("Data/anolis.phy")
