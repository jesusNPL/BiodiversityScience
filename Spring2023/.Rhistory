# Transform back to dataframe
data_na <- ld(data_ade)[, c("id", "x", "y", "date")]
colnames(data_na) <- c("ID", "x", "y", "time")
# Add temperatures for non-missing locations
data_na$temp <- NA
data_na$temp[which(!is.na(data_na$x))] <- data_split$temp
head(data_na, 10)
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- prepData(data_na, type = "UTM", covNames = "temp")
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- momentuHMM::prepData(data_na, type = "UTM", covNames = "temp")
# Observation distributions (step lengths and turning angles)
dist <- list(step = "gamma", angle = "vm")
# Initial parameters
# (step mean 1, step mean 2, step SD 1, step SD 2) and (angle concentration 1, angle concentration 2)
Par0_2s <- list(step = c(0.05, 0.2, 0.05, 0.2), angle = c(0.1, 3))
?momentuHMM::prepData
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- momentuHMM::prepData(data_na, type = "UTM", covNames = "temp")
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- momentuHMM:::prepData(data_na, type = "UTM", covNames = "temp")
install.packages("multimark")
# Movement modelling packages
library(momentuHMM)
remotes::install_github("bmcclintock/momentuHMM")
# Plotting package
library(tidyverse)
theme_set(theme_bw())
# Movement modelling packages
library(momentuHMM)
# install from my R-universe repository
#install.packages("aniMotum", repos = "https://ianjonsen.r-universe.dev")
library(aniMotum)
library(adehabitatLT)
# GIS packages
library(sf)
library(sp)
# Load functions for later
source("https://raw.githubusercontent.com/eco4cast/Statistical-Methods-Seminar-Series/main/michelot_movement/code/utility_functions.R")
install.packages("Brobdingnag")
# Movement modelling packages
library(momentuHMM)
# Plotting package
library(tidyverse)
theme_set(theme_bw())
# Movement modelling packages
library(momentuHMM)
# install from my R-universe repository
#install.packages("aniMotum", repos = "https://ianjonsen.r-universe.dev")
library(aniMotum)
library(adehabitatLT)
# GIS packages
library(sf)
library(sp)
# Load functions for later
source("https://raw.githubusercontent.com/eco4cast/Statistical-Methods-Seminar-Series/main/michelot_movement/code/utility_functions.R")
raw <- read.csv("Downloads/ThermochronTracking Elephants Kruger 2007.csv")
# Keep relevant columns: ID, time, longitude, latitude, temperature
data_all <- raw[, c(9, 3, 4, 5, 6)]
colnames(data_all) <- c("ID", "time", "lon", "lat", "temp")
data_all$time <- as.POSIXct(data_all$time, format = "%Y-%m-%d %H:%M:%S", tz = "GMT")
# Just keep 2000 observations to save time with model fitting
data <- data_all[c(which(data_all$ID == unique(data_all$ID)[5])[1:1000],
which(data_all$ID == unique(data_all$ID)[6])[1:1000]),]
head(data)
# Plot latitude vs longitude (Mercator projection)
ggplot(data, aes(lon, lat, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_map("mercator")
# Longitude vs time
ggplot(data, aes(time, lon, col = ID)) +
geom_point(size = 0.5) + geom_path()
# Latitude vs time
ggplot(data, aes(time, lat, col = ID)) +
geom_point(size = 0.5) + geom_path()
# Project to UTM
llcoord <- st_as_sf(data[, c("lon", "lat")], coords = c("lon", "lat"),
crs = CRS("+proj=longlat +datum=WGS84"))
utmcoord <- st_transform(llcoord, crs = CRS("+proj=utm +zone=35 +datum=WGS84"))
# Add Easting-Northing to data (in km)
data[, c("x", "y")] <- st_coordinates(utmcoord)/1000
# Plot Northing vs Easting
ggplot(data, aes(x, y, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Table of time intervals in data
plot(table(diff(data$time)), xlim = c(0, 300),
xlab = "time interval (min)", ylab = "count")
# Use function from utility_function.R to split data at gaps > 2 hours
data_split <- split_at_gap(data = data, max_gap = 2*60, shortest_track = 24*60)
ggplot(data_split, aes(x, y, col = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Create adehabitat trajectory padded with NAs
data_ade <- setNA(ltraj = as.ltraj(xy = data_split[, c("x", "y")],
date = data_split$time,
id = data_split$ID),
date.ref = data_split$time[1],
dt = 30, tol = 5, units = "min")
# Transform back to dataframe
data_na <- ld(data_ade)[, c("id", "x", "y", "date")]
colnames(data_na) <- c("ID", "x", "y", "time")
# Add temperatures for non-missing locations
data_na$temp <- NA
data_na$temp[which(!is.na(data_na$x))] <- data_split$temp
head(data_na, 10)
# Prepare data for HMM (compute step lengths and turning angles)
data_hmm1 <- momentuHMM::prepData(data_na, type = "UTM", covNames = "temp")
head(data_hmm1, 10)
# Observation distributions (step lengths and turning angles)
dist <- list(step = "gamma", angle = "vm")
# Initial parameters
# (step mean 1, step mean 2, step SD 1, step SD 2) and (angle concentration 1, angle concentration 2)
Par0_2s <- list(step = c(0.05, 0.2, 0.05, 0.2), angle = c(0.1, 3))
# Fit a 2-state HMM
hmm1 <- momentuHMM::fitHMM(data_hmm1, nbStates = 2, dist = dist, Par0 = Par0_2s)
# Print parameter estimates
hmm1
# Plot estimated distributions and state-coloured tracks
plot(hmm1, breaks = 25, ask = FALSE)
# Initial parameters for 3-state model
Par0_3s <- list(step = c(0.02, 0.1, 0.3, 0.02, 0.1, 0.3),
angle = c(0.01, 0.1, 3))
# Fit 3-state HMM
hmm2 <- momentuHMM::fitHMM(data_hmm1, nbStates = 3, dist = dist, Par0 = Par0_3s)
hmm2
plot(hmm2, breaks = 25, ask = FALSE)
# Get most likely sequence of states (Viterbi algorithm)
head(viterbi(hmm2))
# Save most likely state sequences from 2-state and 3-state models
data_hmm1$state_2st <- factor(viterbi(hmm1))
data_hmm1$state_3st <- factor(viterbi(hmm2))
# Plot tracks, coloured by states
ggplot(data_hmm1, aes(x, y, col = state_2st, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
ggplot(data_hmm1, aes(x, y, col = state_3st, group = ID)) +
geom_point(size = 0.5) + geom_path() +
coord_equal()
# Fit 2-state HMM with temperature covariate (linear or quadratic effect)
hmm3 <- momentuHMM::fitHMM(data_hmm1, nbStates = 2, dist = dist,
Par0 = Par0_2s, formula = ~temp)
hmm4 <- momentuHMM::fitHMM(data_hmm1, nbStates = 2, dist = dist,
Par0 = Par0_2s, formula = ~temp+I(temp^2))
# Compare models using AIC
AIC(hmm3, hmm4)
# Plot estimated distributions and transition probabilities as functions of temperature
plot(hmm3, plotTracks = FALSE, ask = FALSE, plotCI = TRUE)
# Plot stationary state probabilities as functions of temperature
plotStationary(hmm3, plotCI = TRUE)
# Plot pseudo-residuals for 2-state and 3-state models
plotPR(hmm1)
plotPR(hmm2)
# Change data to format expected by foieGras
data_foieGras <- data_split[,c("ID", "time", "lon", "lat")]
colnames(data_foieGras)[1:2] <- c("id", "date")
# Add column for location quality class (G for "GPS")
data_foieGras$lc <- "G"
# Change order of columns as expected by foieGras
data_foieGras <- data_foieGras[,c(1, 2, 5, 3, 4)]
##### aniMotum #####
# Fit state-space model to predict regular locations on 0.5h grid
ssm <- fit_ssm(d = data_foieGras, time.step = 0.5)
##### aniMotum #####
# Fit state-space model to predict regular locations on 0.5h grid
ssm <- aniMotum::fit_ssm(d = data_foieGras, time.step = 0.5)
# Predict locations on 30-min grid using crawl (through momentuHMM wrapper)
crw_out <- crawlWrap(obsData = data_split, timeStep = "30 min",
Time.name = "time", coord = c("x", "y"))
data_hmm3 <- prepData(data = crw_out)
# Fit 2-state HMM to regularised data
hmm5 <- fitHMM(data_hmm3, nbStates = 2, dist = dist, Par0 = Par0_2s)
# Fit HMM using multiple imputation
hmm6 <- MIfitHMM(miData = crw_out, nSims = 10, ncores = 3, nbStates = 2,
dist = dist, Par0 = Par0_2s)
plot(hmm6)
library(brms)
install.packages("terra")
install.packages("terra")
install.packages("sf", configure.args = "--with-proj-lib=/usr/local/lib/")
install.packages("sf", configure.args = "--with-proj-lib=/usr/local/lib/")
install.packages("terra")
install.packages("rgdal", configure.args = c("--with-proj-lib=/usr/local/lib/", "--with-proj-include=/usr/local/include/"))
library(terra)
install.packages("sdm", dependencies = TRUE)
sdm::installAll()
sdm::installAll()
devtools::install_git("https://github.com/carlos-alberto-silva/rGEDI", dependencies = TRUE)
devtools::install_git("https://github.com/carlos-alberto-silva/rGEDI", dependencies = TRUE)
install.packages("rstan")
install.packages("rstan", type = "source")
remotes::install_git("https://github.com/carlos-alberto-silva/rGEDI")
gc()
remotes::install_github("carlos-alberto-silva/rGEDI")
# libraries we need
libs <- c("elevatr", "terra", "tidyverse",
"sf", "giscoR", "marmap")
# load libraries
invisible(lapply(libs, library, character.only = T))
crsLONGLAT <- "+proj=longlat +datum=WGS84 +no_defs"
get_sf <- function(country_sf, country_transformed) {
country_sf <- giscoR::gisco_get_countries(
year = "2016",
epsg = "4326",
resolution = "10",
country = c("Ecuador", "Peru", "Brazil", "Colombia"))
country_transformed <- st_transform(country_sf, crs = crsLONGLAT)
return(country_transformed)
}
country_transformed <- get_sf()
get_elevation_data <- function(country_elevation, country_elevation_df) {
country_elevation <- get_elev_raster(
locations = country_transformed,
z = 5,
clip = "locations")
country_elevation_df <- as.data.frame(country_elevation, xy = T) %>%
na.omit()
colnames(country_elevation_df)[3] <- "elevation"
return(country_elevation_df)
}
country_elevation_df <- get_elevation_data()
head(country_elevation_df)
country_elevation_df <- country_elevation_df[country_elevation_df$x > -85,]
country_elevation_df <- country_elevation_df[country_elevation_df$x < -70,]
country_elevation_df <- country_elevation_df[country_elevation_df$y > -15,]
country_elevation_df <- country_elevation_df[country_elevation_df$y < 5,]
country_elevation_df <- country_elevation_df[country_elevation_df$elevation > 0,]
theme_set(theme_classic())
country_map <- ggplot(country_elevation_df, aes(x = x, y = y, fill = elevation)) +
geom_tile() +
borders("world", xlim = c(-85, -70), ylim = c(-15, 5))+
scale_fill_gradient("elevation (m)", low = "gray80", high = "gray28") +
coord_sf(crs = crsLONGLAT)+
theme_void()
country_map
ggplot(country_elevation_df, aes(x = x, y = y, fill = elevation)) +
geom_tile() +
scale_fill_gradient("elevation (m)", low = "gray80", high = "gray28") +
coord_sf(crs = crsLONGLAT)+
theme_void()
ggplot(country_elevation_df, aes(x = x, y = y, fill = elevation)) +
geom_tile() +
scale_fill_gradient("elevation (m)", low = "gray80", high = "gray28") +
coord_sf(crs = crsLONGLAT) +
theme_void()
dev.off()
gc()
?get_elev_raster
?giscoR::gisco_get_countries
?get_elev_point
load("~/Dropbox/FURNARIIDES/Furnariides_phylogeny/ClaDS/ClaDS_furnariides_new.RData")
library(RPANDA)
?ClaDS0_example
CladsOutput$tree
MAPS = getMAPS_ClaDS0(CladsOutput$tree,
CladsOutput$chains,
thin = 10)
data(ClaDS0_example)
ClaDS0_example$speciation_rates
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:4)
ClaDS0_example$speciation_rates
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:4)
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:4)
dev.off()
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:4)
plot_ClaDS0_chains(ClaDS0_example$Cl0_chains, param = 1:2)
plot_ClaDS0_chains(CladsOutput$chains, param = 1:2)
plot_ClaDS0_chains(CladsOutput$chains[[1]], param = 1:2)
plot_ClaDS0_chains(CladsOutput$chains[[1]][[1]], param = 1:2)
# extract the Maximum A Posteriori for each of the parameters
MAPS = getMAPS_ClaDS0(ClaDS0_example$tree,
ClaDS0_example$Cl0_chains,
thin = 10)
MAPS
# plot the simulated (on the left) and inferred speciation rates (on the right)
# on the same color scale
plot_ClaDS_phylo(ClaDS0_example$tree,
ClaDS0_example$speciation_rates,
MAPS[-(1:3)])
ClaDS0_example$Cl0_chains
head(ClaDS0_example$Cl0_chains)
class(ClaDS0_example$Cl0_chains)
class(ClaDS0_example$Cl0_chains[[1]])
(CladsOutput$chains[[1]])
class(CladsOutput$chains[[1]])
class(CladsOutput$chains[[1]][[1]])
class(CladsOutput$chains[[1]][[100]])
CladsOutput$chains[[1]][[100]]
hist(CladsOutput$chains[[1]][[100]])
hist(CladsOutput$chains[[2]][[100]])
hist(CladsOutput$chains[[3]][[100]])
hist(CladsOutput$chains[[4]][[100]])
class(ClaDS0_example$Cl0_chains[[2]])
class(ClaDS0_example$Cl0_chains[[3]])
class(ClaDS0_example$Cl0_chains[[4]])
class(ClaDS0_example$Cl0_chains[[3]])
ClaDS0_example$Cl0_chains[[3]]
install.packages("itsdm")
library(itsdm, quietly = TRUE)
library(tidyverse)
library(stars)
library(rnaturalearth)
# Bioclimatic variables
data("mainland_africa")
force(mainland_africa)
bios <- worldclim2(var = 'bio',
bry = mainland_africa,
path = "Donwloads",
nm_mark = 'africa') %>%
st_normalize()
?worldclim2
bios <- worldclim2(var = 'bio',
bry = mainland_africa,
path = "Downloads/",
nm_mark = 'africa') %>%
st_normalize()
bios <- worldclim2(var = 'bio',
bry = mainland_africa,
#path = "Downloads/",
nm_mark = 'africa') %>%
st_normalize()
install.packages("terra", type = "source")
install.packages("terra", type = "source")
setwd("Documents/GitHub/BiodiversityScience/Spring2023/")
?phytools::phylosig
#| eval: false
packages <- c("tidyverse", "ape", "geiger", "nlme", "phytools", "rr2")
# Package vector names
#| eval: false
# Install packages not yet installed
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
install.packages(packages[!installed_packages], dependencies = TRUE)
}
library(tidyverse)
library(ape)
library(geiger)
library(nlme)
library(phytools)
library(rr2)
?dir.create
## Trait data
furnaData <- read_csv("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2023/Lab_1/Data/furnariides_traits.csv") %>%
column_to_rownames("Sciname") %>%   # we are using the column "Sciname" as rownames
drop_na(Range.Size)
## Phylogenetic data
furnaTree <- read.nexus("https://raw.githubusercontent.com/jesusNPL/BiodiversityScience/master/Spring2023/Lab_1/Data/furnariides_tree.nex")
glimpse(furnaData)
tmp <- name.check(phy = furnaTree, data = furnaData)
tmp
furnaTree <- drop.tip(phy = furnaTree, tip = tmp$tree_not_data)
name.check(phy = furnaTree, data = furnaData)
#| eval: false
plot(furnaTree)
#| eval: false
plot.phylo(furnaTree, no.margin = TRUE, cex = 0.5)
plot.phylo(furnaTree, type = "fan", no.margin = TRUE, cex = 0.3)
#| eval: false
furnaTree
#| eval: false
str(furnaTree)
#| eval: false
plot.phylo(furnaTree, type = "fan", no.margin = TRUE, cex = 0.7, label.offset = 0.1)
nodelabels(cex = 0.5)
tiplabels(cex = 0.5)
#| eval: false
furnaData %>%
head() # this will show you the first few rows of your data matrix and its header
furnaData %>%
dimnames() # this will show you the row and column headers for your matrix
furnaData %>%
View() # this will let you visualize the entire matrix
hwi <- furnaData[, "Hand-Wing.Index"]
names(hwi) <- rownames(furnaData)
# data vectors have to be labelled with tip names for the associated tree.
# This is how to do that.
hist(hwi)
#| eval: false
contMap(furnaTree, hwi, fsize = 0.5, lwd = 3)
#| eval: false
lm_hwi_rangesize <- lm(log(rangeSize) ~ hwi)
#| eval: false
rangeSize <- furnaData[, "Range.Size"]
names(rangeSize) <- rownames(furnaData)
#| eval: false
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "Hand-Wing Index", y = "log(Range Size)")
#| eval: false
lm_hwi_rangesize <- lm(log(rangeSize) ~ hwi)
summary(lm_hwi_rangesize)
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "Hand-Wing Index", y = "log(Range Size)") +
geom_smooth(method = "lm")
#| eval: false
furnaTree$Nnode
#| eval: false
furnaTree$edge
hwi <- furnaData[, "Hand-Wing.Index"]
names(hwi) <- rownames(furnaData)
# data vectors have to be labelled with tip names for the associated tree.
# This is how to do that.
hist(hwi)
#| eval: false
brownianModel <- fitContinuous(furnaTree, hwi)
brownianModel # this will show you the fit statistics and parameter values
#| eval: false
rangeSize <- furnaData[, "Range.Size"]
names(rangeSize) <- rownames(furnaData)
#| eval: false
lm_hwi_rangesize <- lm(log(rangeSize) ~ hwi)
summary(lm_hwi_rangesize)
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "Hand-Wing Index", y = "log(Range Size)") +
geom_smooth(method = "lm")
#| eval: false
pglsModel <- gls(log(rangeSize) ~ hwi,
correlation = corBrownian(phy = furnaTree, form=~names(rangeSize)),
method = "ML")
#| eval: false
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "Hand-Wing Index", y = "log(Range Size)") +
#geom_smooth(method = "lm") +
geom_abline(intercept = coef(pglsModel)[1], slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5)
# will plot the pgls regression line on your biplot.
#| eval: false
brownianModel <- fitContinuous(furnaTree, hwi)
#| eval: false
OUModel <- fitContinuous(furnaTree, hwi, model = "OU")
#| eval: false
EBModel <- fitContinuous(furnaTree, hwi, model = "EB")
#| eval: false
brownianModel
OUModel
EBModel
#| eval: false
aicw(c(brownianModel$opt$aicc, OUModel$opt$aicc, EBModel$opt$aicc))
#| eval: false
furnaData %>%
drop_na(Range.Size) %>%
ggplot(aes(x = `Hand-Wing.Index`, y = log(Range.Size))) +
geom_point(alpha = 0.5, color = "darkgray") +
labs(x = "Hand-Wing Index", y = "log(Range Size)") +
geom_smooth(method = "lm") +
geom_abline(intercept = coef(pglsModel)[1], slope = coef(pglsModel)[2],
color = "red", linewidth = 1.5)
#| eval: false
rshwi.sum <- summary(lm_hwi_rangesize)
#for the uncorrected linear model
rshwi.sum$coef[2, 1] + c(-1.96, 1.96)*rshwi.sum$coef[2, 2]
#for Brownian Motion, the 95% CI
coef(pglsModel)[2] + c(-1.96, 1.96)*sqrt(pglsModel$varBeta[2, 2])
#| eval: false
K_hwi <- phylosig(tree = furnaTree, # Phylogeny
x = hwi, # trait
method = "K", # method
test = TRUE)
print(K_hwi)
plot(K_hwi)
#| eval: false
LB_hwi <- phylosig(tree = furnaPhylo,
x = hwi,
method = "lambda",
test = TRUE)
#| eval: false
LB_hwi <- phylosig(tree = furnaTree,
x = hwi,
method = "lambda",
test = TRUE)
print(LB_hwi)
plot(LB_hwi)
#| eval: false
habitat <- furnaData$Habitat_recode
names(habitat) <- rownames(furnaData)
table(habitat)
#| eval: false
habitat_anc <- make.simmap(furnaTree, habitat, model = "SYM", nsim = 100)
#| eval: false
plotSimmap(habitat_anc[[1]], fsize = 0.5) # this plots the first of 100 simulations
#| eval: false
countSimmap(habitat_anc[[1]])
#| eval: false
habitat_summary <- summary(habitat_anc)
habitat_summary # print the results
#| eval: false
plot(habitat_summary, cex = c(0.5, 0.2), fsize = 0.5, offset = 90)
legend("bottomleft", fill = c("black", "red", "green"),
legend = c("Forest", "Savanna", "Transition"))
#| eval: false
cols <- setNames(c("darkgreen", "khaki", "gray"),
c("Forest", "Savanna", "Transition"))
#| eval: false
plotSimmap(habitat_anc[[1]], cols)
add.simmap.legend(colors = cols, prompt = FALSE, x = 0, y = -0.5,
vertical = FALSE)
#| eval: false
plotSimmap(habitat_anc[[1]], fsize = 0.5) # this plots the first of 100 simulations
#| eval: false
habitat_summary <- summary(habitat_anc)
habitat_summary # print the results
